        program sddffx

*** static double difference phase -- float and fix ambig.

***debug -- validate sc clock corr to p/r inside geomet()/getepoch()
*** debug -- not seeing corrections for sv clock error to obs. range

*** icd200block icd-gps-200c + irn-200c-002 97sep25
***   parameter(gm   = 3.986005d14)                     !*** 20.3.3.3.3.1
***   parameter(we   = 7.2921151467d-5) !*** rad/sec    !*** table 20-IV
***   parameter(gpspi= 3.1415926535898d0)               !*** 20.3.3.4.3.2
***   parameter(sol  = 299792458.d0)                    !*** 20.3.4.3
***   parameter(bigf =-4.442807633d-10) !*** sec/m**0.5 !*** 20.3.3.3.3.1

      implicit double precision(a-h,o-z)
      parameter(mxprn=32,mxepch=192)
      dimension orbits(mxepch + 4*mxprn*mxepch)
      save  /dat3/
      common/dat3/dtr1a,dtr2b
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

      pi=4.d0*datan(1.d0)
      rad=180.d0/pi

      sol=299792458.d0
      f1 =1575.42d6
      f2 =1227.60d6
      w1 =sol/f1
      w2 =sol/f2
      we=7.2921151467d-5

*** input file names

      lst=1
      open(lst,file='sddffx.lst',form='formatted')
      write(lst,'(a)')
     *      'sddffx -- Static DD Phase (float-fix) -- 2006jun10'

      lin=2
      open(lin,file='gmerge.out',form='formatted',status='old')

      leph=3
      open(leph,file='orbit.sp3',form='formatted',status='old')

      lres=4
      open(lres,file='sddffx.res',form='formatted')

*** get header info from merge file

      call mrhead

*** load precise ephemeris -- close file and reuse logical unit

      rewind(leph)
      call lodorb(orbits)
      close(leph)

*** load broadcast ephemeris -- then close file

      leph=3
      open(leph,file='nav',form='formatted',status='old')
      call blodorb
      close(leph)
      leph=6

*** query for modes

      call modequery
      call dumpmodes

*** support for receiver bias

      dtr1a  =0.d0                      !*** initialize (if used or not)
      dtr2b  =0.d0

      call mrhdump                      !*** dump some data info

      call mrhead2                      !*** rewind/bypass head
      call swrapper(orbits)             !*** wrapper for computation

*** end of processing

      write(lst,'(a)') 'End of Processing'
      end
************************************************************************
      subroutine swrapper(orbits)

*** outer wrapper for static DD phase computation
*** performs iterative rejections

      implicit double precision(a-h,o-z)
      logical xyzgeo
      parameter(mxpr=32,mxt=101,mxx=mxpr*mxt+3)
      dimension x(mxx)
      parameter(mxprn=32,mxepch=192)
      dimension orbits(mxepch + 4*mxprn*mxepch)
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we
      save  /tlimit/
      common/tlimit/nloop,nloopmx

*** rms used to derive data rejection tolerance

      rms =100000.d0             !*** initialize to large value (m.)
      smax=100000.d0             !*** initialize to large value (m.)
      rmsx =rms

*** loop over the adjustment  (do auto-rejection)
*** set number of epochs to maximum

      call gettsuf(tmn,tmx,dlt)
      nloop=idnint((tmx-tmn)/dlt)+1

*** 1 write(*,'(i6,a$)') nloop,' epochs -- how many? '
***   read(*,*)          nloopmx
***   if(nloopmx.le.2) go to 1
***   if(nloopmx.gt.nloop) nloopmx=nloop
      nloopmx=nloop

*** make newest ambiguity table

      call make(orbits)
      namb=nsize()
      write(lst,'(a,i5,a,i4)') '# epochs=',nloopmx,'   # ambig=',namb
      nunk=3+namb

      postol=0.001d0
      sigtol=0.05d0
      siglvl=2.75d0
      maxitr=10
      iter=1
10000 if(iter.le.maxitr) then
        write(*,*) ' iteration -- ',iter
        rejlvm=siglvl*rms
        call sddflsq(orbits,x,rejlvm,rms,smax,nobs,namb,nunk)
        write(lst,'(a,i7,a,f10.4,a,f8.4)')
     *    '# obs=',nobs,'   Shift=',smax,' m.   RMS =',rms
        iter=iter+1
        if(dabs(smax).gt.postol.or.(dabs(rms-rmsx)/rms).gt.sigtol) then
          rmsx =rms
          go to 10000
        endif
      endif

      call mrhead2
      call post1                             !*** report on float coord.

*** now rebuild the table (with latest coordinate)

      write(lst,'(a)')'============ fix ambiguities ==================='
      
      call make(orbits)
      namb=nsize()
      write(lst,'(a,i4)') '# ambig=',namb

      nunk=3

      rms =1.d0                                   !*** re-initialize  (m.)
      maxitr=10
      iter=1
20000 if(iter.le.maxitr) then
        write(*,*) ' iteration -- ',iter
        rejlvm=siglvl*rms
        call sddfxlsq(orbits,x,rejlvm,rms,smax,nobs,namb,nunk)
        write(lst,'(a,i7,a,f10.4,a,f8.4)')
     *    '# obs=',nobs,'   Shift=',smax,' m.   RMS =',rms
        iter=iter+1
        if(dabs(smax).gt.postol.or.(dabs(rms-rmsx)/rms).gt.sigtol) then
          rmsx =rms
          go to 20000
        endif
      endif

      call mrhead2
      call post1                             !*** report on fix coord.

*** now rebuild the table (with trimmed coordinate)

      write(lst,'(a)')'============ re-fix ambiguities ================'
      
      call make(orbits)
      namb=nsize()
      write(lst,'(a,i4)') '# ambig=',namb

      nunk=3

      rms =0.2d0                                   !*** re-initialize  (m.)
      maxitr=10
      iter=1
30000 if(iter.le.maxitr) then
        write(*,*) ' iteration -- ',iter
        rejlvm=siglvl*rms
        call sddfxlsq(orbits,x,rejlvm,rms,smax,nobs,namb,nunk)
        write(lst,'(a,i7,a,f10.4,a,f8.4)')
     *    '# obs=',nobs,'   Shift=',smax,' m.   RMS =',rms
        iter=iter+1
        if(dabs(smax).gt.postol.or.(dabs(rms-rmsx)/rms).gt.sigtol) then
          rmsx =rms
          go to 30000
        endif
      endif



*** provide results

      call mrhead2
      call post(orbits,rejlvm,namb,nunk)

      return
      end
************************************************************************
      subroutine sddflsq(orbits,x,rejlvm,rms,smax,nobs,namb,nunk)

*** guts of static DD phase (good prior) computation

      implicit double precision(a-h,o-z)
      logical getepch
      parameter(mxprn=32,mxepch=192)
      dimension orbits(mxepch + 4*mxprn*mxepch)
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we
      parameter(mxpr=32,mxt=101,mxx=mxpr*mxt+3)
      dimension an(mxx,mxx),u(mxx),x(mxx)
      save  /tlimit/
      common/tlimit/nloop,nloopmx

      call mrhead2

*** initialize normals

      nobs=0
      call nitil2(an,u,eltpel,nunk)

*** accumulate normals

      sigddm=0.01d0                                   !*** units of m.
      do iloop=1,nloopmx
        if(.not.getepch(dlt)) go to 700               !*** read data file
        call geomet(orbits)                           !*** solve geometry
        call ddfacc(an,u,eltpel,rejlvm,sigddm,nunk,namb,ns)
        nobs=nobs+ns
      enddo
  700 continue

*** end of accumulation -- invert, solve

      call fill(an,nunk)
      call invert(an,nunk)
      call ab(an,u,x,nunk,nunk,1)
      call update(x,namb)

*** coord. shift

      smax=dsqrt(x(namb+1)*x(namb+1)+
     *           x(namb+2)*x(namb+2)+
     *           x(namb+3)*x(namb+3))    

*** compute rms from "basement window"  (v'pv=l'pl-x'u)

      call vecprd(x,u,nunk,val)
      if((eltpel-val).lt.0.d0) then
        write(*,*) 'negative rms'
        write(*,*) 'fatal error'
        stop 98765
      endif
      rms=dsqrt((eltpel-val)/dble(nobs))*sigddm

      return
      end
************************************************************************
      subroutine ddfacc(an,u,eltpel,rejlvm,sigddm,nunk,namb,ns)

*** accumulate an epoch of DD phase (supress ambiguities)
*** uses direct indexing into data commons

      implicit double precision(a-h,o-z)
      logical get
      parameter(mxprn=32)
      parameter(mxpr=32,mxt=101,mxx=mxpr*mxt+3)
      dimension an(mxx,mxx),u(mxx),x(mxx)
      dimension c(4),ic(4)
      parameter(rnull2=999999999.d0,tiny=1.d-2)
      save  /dat0/,/dat1/,/dat2/
      dimension iprns(mxprn)
      common/dat0/nsat,iprns,iprnhi
      dimension r11(mxprn),p11(mxprn),r21(mxprn),p21(mxprn),s1(mxprn),
     *          dx1(mxprn),dy1(mxprn),dz1(mxprn),va1(mxprn),az1(mxprn),
     *          dts1(mxprn)
      common/dat1/t1,r11,p11,r21,p21,s1,dx1,dy1,dz1,va1,az1,dts1
      dimension r12(mxprn),p12(mxprn),r22(mxprn),p22(mxprn),s2(mxprn),
     *          dx2(mxprn),dy2(mxprn),dz2(mxprn),va2(mxprn),az2(mxprn),
     *          dts2(mxprn)
      common/dat2/t2,r12,p12,r22,p22,s2,dx2,dy2,dz2,va2,az2,dts2
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** weight (DD observation is in units of cycles)

      sig=sigddm/w1                     !*** meters to cycles
      pwt=1.d0/(sig*sig)

*** accumulate normals
*** r-range, p-phase, s-model, 1st number-frequency, 2nd number-station

*** first differences (between stations) (for high sat)

      if(p11(iprnhi).gt.rnull2.or.s1(iprnhi).lt.tiny) return
      if(p12(iprnhi).gt.rnull2.or.s2(iprnhi).lt.tiny) return
      dphi=p12(iprnhi)-p11(iprnhi)
      dshi= s2(iprnhi)- s1(iprnhi)

*** direction cosines for station 2 (only)

      cs12=-dx2(iprnhi)/s2(iprnhi)
      cs22=-dy2(iprnhi)/s2(iprnhi)
      cs32=-dz2(iprnhi)/s2(iprnhi)

      ns=0
      do 100 iloop=1,nsat
        i=iprns(iloop)                   !*** prn of the measurements
        if(i.eq.iprnhi) go to 100
        if(p11(i).gt.rnull2.or.s1(i).lt.tiny) go to 100
        if(p12(i).gt.rnull2.or.s2(i).lt.tiny) go to 100

        dplo=p12(i)-p11(i)
        dslo= s2(i)- s1(i)

        ddp = dplo-dphi                    !*** units of phase (cycle)
        dds = dslo-dshi
        cmo = dds/w1-ddp                   !*** units of phase (cycle)

        if(.not.get(t1,i,iam)) stop 34966
        nc   =4
        ic(1)=iam                          !*** ambiguity
        ic(2)=namb+1                       !*** rover X
        ic(3)=namb+2                       !*** rover Y
        ic(4)=namb+3                       !*** rover Z
        c(1) =+1.d0                        !*** ambiguity
        c(2) =(-dx2(i)/s2(i) - cs12)/w1    !*** rover X -- parameter meters
        c(3) =(-dy2(i)/s2(i) - cs22)/w1    !*** rover Y -- parameter meters
        c(4) =(-dz2(i)/s2(i) - cs32)/w1    !*** rover Z -- parameter meters

        cmo = cmo + aget(iam)              !*** correct w/ambig value

        if(dabs(cmo*w1).le.rejlvm) then    !*** reject tol. in meters
          ns=ns+1
          call nrmal2(an,u,c,cmo,pwt,eltpel,ic,nc,nunk)
        else                               !*** d-weight by 1000 if exceed tol
          call nrmal2(an,u,c,cmo,pwt/1000.d0,eltpel,ic,nc,nunk)
        endif
  100 continue

      return
      end
************************************************************************
      subroutine sddfxlsq(orbits,x,rejlvm,rms,smax,nobs,namb,nunk)

*** guts of static DD phase (good prior) computation

      implicit double precision(a-h,o-z)
      logical getepch
      parameter(mxprn=32,mxepch=192)
      dimension orbits(mxepch + 4*mxprn*mxepch)
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we
      parameter(mxx=3)
      dimension an(mxx,mxx),u(mxx),x(mxx)
      save  /tlimit/
      common/tlimit/nloop,nloopmx

      call mrhead2

*** initialize normals

      nobs=0
      call nitil2(an,u,eltpel,nunk)

*** accumulate normals

      sigddm=0.01d0                                   !*** units of m.
      do iloop=1,nloopmx
        if(.not.getepch(dlt)) go to 700               !*** read data file
        call geomet(orbits)                           !*** solve geometry
        call ddfxacc(an,u,eltpel,rejlvm,sigddm,nunk,namb,ns)
        nobs=nobs+ns
      enddo
  700 continue

*** end of accumulation -- invert, solve

      call fill(an,nunk)
      call invert(an,nunk)
      call ab(an,u,x,nunk,nunk,1)
      call update2(x)

*** coord. shift

      smax=dsqrt(x(1)*x(1)+
     *           x(2)*x(2)+
     *           x(3)*x(3))    

*** compute rms from "basement window"  (v'pv=l'pl-x'u)

      call vecprd(x,u,nunk,val)
      if((eltpel-val).lt.0.d0) then
        write(*,*) 'negative rms'
        write(*,*) 'fatal error'
        stop 98865
      endif
      rms=dsqrt((eltpel-val)/dble(nobs))*sigddm

      return
      end
************************************************************************
      subroutine ddfxacc(an,u,eltpel,rejlvm,sigddm,nunk,namb,ns)

*** accumulate an epoch of DD phase (supress ambiguities)
*** uses direct indexing into data commons

      implicit double precision(a-h,o-z)
      logical get
      parameter(mxprn=32)
      parameter(mxx=+3)
      dimension an(mxx,mxx),u(mxx),x(mxx)
      dimension c(3),ic(3)
      parameter(rnull2=999999999.d0,tiny=1.d-2)
      save  /dat0/,/dat1/,/dat2/
      dimension iprns(mxprn)
      common/dat0/nsat,iprns,iprnhi
      dimension r11(mxprn),p11(mxprn),r21(mxprn),p21(mxprn),s1(mxprn),
     *          dx1(mxprn),dy1(mxprn),dz1(mxprn),va1(mxprn),az1(mxprn),
     *          dts1(mxprn)
      common/dat1/t1,r11,p11,r21,p21,s1,dx1,dy1,dz1,va1,az1,dts1
      dimension r12(mxprn),p12(mxprn),r22(mxprn),p22(mxprn),s2(mxprn),
     *          dx2(mxprn),dy2(mxprn),dz2(mxprn),va2(mxprn),az2(mxprn),
     *          dts2(mxprn)
      common/dat2/t2,r12,p12,r22,p22,s2,dx2,dy2,dz2,va2,az2,dts2
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** weight (DD observation is in units of cycles)

      sig=sigddm/w1                     !*** meters to cycles
      pwt=1.d0/(sig*sig)

*** accumulate normals
*** r-range, p-phase, s-model, 1st number-frequency, 2nd number-station

*** first differences (between stations) (for high sat)

      if(p11(iprnhi).gt.rnull2.or.s1(iprnhi).lt.tiny) return
      if(p12(iprnhi).gt.rnull2.or.s2(iprnhi).lt.tiny) return
      dphi=p12(iprnhi)-p11(iprnhi)
      dshi= s2(iprnhi)- s1(iprnhi)

*** direction cosines for station 2 (only)

      cs12=-dx2(iprnhi)/s2(iprnhi)
      cs22=-dy2(iprnhi)/s2(iprnhi)
      cs32=-dz2(iprnhi)/s2(iprnhi)

      ns=0
      do 100 iloop=1,nsat
        i=iprns(iloop)                   !*** prn of the measurements
        if(i.eq.iprnhi) go to 100
        if(p11(i).gt.rnull2.or.s1(i).lt.tiny) go to 100
        if(p12(i).gt.rnull2.or.s2(i).lt.tiny) go to 100

        dplo=p12(i)-p11(i)
        dslo= s2(i)- s1(i)

        ddp = dplo-dphi                    !*** units of phase (cycle)
        dds = dslo-dshi
        cmo = dds/w1-ddp                   !*** units of phase (cycle)

        if(.not.get(t1,i,iam)) stop 34966
        nc   =3
        ic(1)=1                            !*** rover X
        ic(2)=2                            !*** rover Y
        ic(3)=3                            !*** rover Z
        c(1) =(-dx2(i)/s2(i) - cs12)/w1    !*** rover X -- parameter meters
        c(2) =(-dy2(i)/s2(i) - cs22)/w1    !*** rover Y -- parameter meters
        c(3) =(-dz2(i)/s2(i) - cs32)/w1    !*** rover Z -- parameter meters

        cmo = cmo + aget(iam)              !*** correct w/ambig value

        if(dabs(cmo*w1).le.rejlvm) then    !*** reject tol. in meters
          ns=ns+1
          call nrmal2(an,u,c,cmo,pwt,eltpel,ic,nc,nunk)
        else                               !*** d-weight by 1000 if exceed tol
          call nrmal2(an,u,c,cmo,pwt/1000.d0,eltpel,ic,nc,nunk)
        endif
  100 continue

      return
      end
************************************************************************
      subroutine post(orbits,rejlvm,namb,nunk)

*** do post processing of residuals

      implicit double precision(a-h,o-z)
      character*4 pnam2
      logical getepch
      parameter(mxprn=32,mxepch=192)
      dimension orbits(mxepch + 4*mxprn*mxepch)
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we
      save  /tlimit/
      common/tlimit/nloop,nloopmx

*** final coordinates and shift

      write(lst,'(a4,a)') pnam2(),' output referenced to mark'
      call getmk2g(gla,glo,eht)
      write(lst,'(a4,a,2f15.9,f10.4)')
     *            pnam2(),' MARK=',gla*rad,glo*rad,eht

      if(glo.gt.pi) then
        glo=glo-pi-pi
        write(lst,'(a4,a,2f15.9,f10.4)')
     *              pnam2(),' MARK=',gla*rad,glo*rad,eht
      endif

      call todms(gla*rad,idla,imla,sla)
      call todms(glo*rad,idlo,imlo,slo)

      write(lst,'(a4,a,2i3.2,f9.5,i7,i3.2,f9.5,f12.4)')
     *            pnam2(),' MARK=',idla,imla,sla,idlo,imlo,slo,eht

      call getmk2 (xk2 ,yk2 ,zk2 )
      call getomk2(xk2o,yk2o,zk2o)

      dx=xk2-xk2o
      dy=yk2-yk2o
      dz=zk2-zk2o
      call getomk2g(glao,gloo,ehto)                   !*** bugfix 060526
      call rge(glao,gloo,dn,de,du,dx,dy,dz)
      write(lst,'(a)') 'delta N/E/U at point 2 mark'
      write(lst,'(3f14.4))') dn,de,du

*** final residuals and statistics

      vs  =0.d0
      vs2 =0.d0
      vst =0.d0
      vst2=0.d0
      nv  =0
      nvt =0
      do iloop=1,nloopmx
        if(.not.getepch(dlt)) go to 700               !*** read data file
        call geomet(orbits)                           !*** solve geometry
        call ddtpost(rejlvm,vs,vs2,vst,vst2,nv,nvt,namb)
      enddo
  700 continue
      rmsut=dsqrt(vs2 /dble(nv ))
      rmst =dsqrt(vst2/dble(nvt))

*** summary stats

      write(lst,'(a,f9.4,a,i6)') 'untrimmed rms =',rmsut,' m.    n=',nv
      write(lst,'(a,f9.4,a,i6)') '  trimmed rms =',rmst ,' m.    n=',nvt

      return
      end
      subroutine ddtpost(rejlvm,vs,vs2,vst,vst2,nv,nvt,namb)

*** compute an epoch of DD phase (supress ambiguities) residuals
*** residual sign sense is cmo  (following ddpr1)

      implicit double precision(a-h,o-z)
      logical get
      parameter(mxprn=32)
      parameter(rnull2=999999999.d0,tiny=1.d-2)
      save  /dat0/,/dat1/,/dat2/
      dimension iprns(mxprn)
      common/dat0/nsat,iprns,iprnhi
      dimension r11(mxprn),p11(mxprn),r21(mxprn),p21(mxprn),s1(mxprn),
     *          dx1(mxprn),dy1(mxprn),dz1(mxprn),va1(mxprn),az1(mxprn),
     *          dts1(mxprn)
      common/dat1/t1,r11,p11,r21,p21,s1,dx1,dy1,dz1,va1,az1,dts1
      dimension r12(mxprn),p12(mxprn),r22(mxprn),p22(mxprn),s2(mxprn),
     *          dx2(mxprn),dy2(mxprn),dz2(mxprn),va2(mxprn),az2(mxprn),
     *          dts2(mxprn)
      common/dat2/t2,r12,p12,r22,p22,s2,dx2,dy2,dz2,va2,az2,dts2
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** compute residuals
*** r-range, p-phase, s-model, 1st number-frequency, 2nd number-station

*** first differences (between stations) (for high sat)

      if(p11(iprnhi).gt.rnull2.or.s1(iprnhi).lt.tiny) return
      if(p12(iprnhi).gt.rnull2.or.s2(iprnhi).lt.tiny) return
      dphi=p12(iprnhi)-p11(iprnhi)
      dshi= s2(iprnhi)- s1(iprnhi)

      do 100 iloop=1,nsat
        i=iprns(iloop)                   !*** prn of the measurements
        if(i.eq.iprnhi) go to 100
        if(p11(i).gt.rnull2.or.s1(i).lt.tiny) go to 100
        if(p12(i).gt.rnull2.or.s2(i).lt.tiny) go to 100

        dplo=p12(i)-p11(i)
        dslo= s2(i)- s1(i)

        ddp = dplo-dphi                     !*** units of phase (cycle)
        dds = dslo-dshi
        cmo = dds/w1-ddp                    !*** units of phase (cycle)

        if(.not.get(t1,i,iam)) stop 34962
        cmo = cmo + aget(iam)               !*** correct w/ambig value
        cmom= cmo*w1                        !*** cycles to meters

        write(lres,'(f9.1,f9.4,f6.2,i3)') t1,cmom,va1(i)*rad,i

*** accumulate untrimmed and trimmed residual statistics

        vs =vs + cmom
        vs2=vs2+(cmom*cmom)
        nv =nv +1
        if(dabs(cmom).le.rejlvm) then
          vst =vst + cmom
          vst2=vst2+(cmom*cmom)
          nvt =nvt +1
        endif
  100 continue

      return
      end
************************************************************************
      subroutine post1

*** float coordinate solution

      implicit double precision(a-h,o-z)
      character*4 pnam2
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** float coordinates and shift

      write(lst,'(a4,a)') pnam2(),' output referenced to mark'
      call getmk2g(gla,glo,eht)
      write(lst,'(a4,a,2f15.9,f10.4)')
     *            pnam2(),' MARK=',gla*rad,glo*rad,eht

      if(glo.gt.pi) then
        glo=glo-pi-pi
        write(lst,'(a4,a,2f15.9,f10.4)')
     *              pnam2(),' MARK=',gla*rad,glo*rad,eht
      endif

      call todms(gla*rad,idla,imla,sla)
      call todms(glo*rad,idlo,imlo,slo)

      write(lst,'(a4,a,2i3.2,f9.5,i7,i3.2,f9.5,f12.4)')
     *            pnam2(),' MARK=',idla,imla,sla,idlo,imlo,slo,eht

      call getmk2 (xk2 ,yk2 ,zk2 )
      call getomk2(xk2o,yk2o,zk2o)

      dx=xk2-xk2o
      dy=yk2-yk2o
      dz=zk2-zk2o
      call getomk2g(glao,gloo,ehto)                   !*** bugfix 060526
      call rge(glao,gloo,dn,de,du,dx,dy,dz)
      write(lst,'(a)') 'delta N/E/U at point 2 mark'
      write(lst,'(3f14.4))') dn,de,du

      return
      end
************************************************************************
*** forward model stuff   **********************************************
************************************************************************
      logical function comrng(iprn,orbits,t,x,y,z,gla,glo,r,s,dx,dy,dz,
     *                        va,az,dts)

*** compute range to satellite from point
*** input times -- biased receiver time of receipt, t
*** input coord -- ECEF coord of a point, x,y,z (also lat/lon)
*** input range -- measured pseudorange (for rcvr. time bias), r
*** output sat clock corrected for relativity (and tgd) with bc orbit
*** version: 2006may11-11:48a

      implicit double precision(a-h,o-z)
      parameter(rnull2=999999999.d0)
      logical oterp,selectbc,lq2frq
      parameter(tgdave=-8.076d-9)               !*** mean tgd (sec.)
      dimension orbits(*)
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

      if(r.gt.rnull2) then                      !*** valid pseudorange?
        comrng=.false.
        return
      endif

*** select broadcast elements (for relativity and tgd correction)

      if(.not.selectbc(iprn,t,tsow,ierr)) then
        comrng=.false.
        return
      else
        tsv  =djtssow(t-0.075d0)      !*** approximate tt w/ trecvr-75ms
        dtbc =bcclok1(tsv)
        dtrl =bcclok2(tsv,dtbc)       !*** relativity correction
      endif

*** iterate the light loop twice                 (confirmed-- 2004aug30)
*** dt  -- delta time (transit time -- tau)
*** tt  -- transmit time
*** dtr -- receiver time bias
*** dts -- satellite time bias (from .sp3)
*** dtrl-- relativistic clock correction (use bc orbit)

      dtr=0.d0
      dt=0.075d0
      do 1 i=1,2
        tt=(t-dtr)-dt
        if(.not.oterp(iprn,tt,orbits,xs,ys,zs,dts,ierr)) then
          comrng=.false.
          return
        endif

        if(.not.lq2frq())             !*** IGS clock convention same as ICD
     *     dts=dts-(bctgd()-tgdave)   !*** icd200 -- 20.3.3.3.3.2
                                      !*** zero-mean GD applied per IGS/CODE

        dts=dts+dtrl                  !*** relativity corrn to precise clock
                                      !*** icd200 -- 20.3.3.3.3.1
        dx=xs-x
        dy=ys-y
        dz=zs-z
        s=dsqrt(dx*dx+dy*dy+dz*dz)

        dt=s/sol
        dtr=r/sol-dt+dts             !*** contains propogation/multipath
    1 continue

*** now apply sagnac effect for the range
***    (icd200c -- 20.3.3.4.3.4 -- "add to pos." -or- subtract from sat.)

      sag=we*dt
      dx =xs+sag*ys-x
      dy =ys-sag*xs-y
      dz =zs       -z
      s  =dsqrt(dx*dx+dy*dy+dz*dz)

*** vert angle and azimuth in local geodetic horizon

      call rge(gla,glo, dn,de,du, dx,dy,dz)
      va=datan(du/dsqrt(dn*dn+de*de))
      az=datan2(de,dn)
      comrng=.true.

      return
      end
************************************************************************
      logical function comrng2(iprn,orbits,t,x,y,z,gla,glo,dtr,s,
     *                         dx,dy,dz,va,az,dts)

*** compute range to satellite from point
*** this version uses external/input receiver time bias, dtr ***********
*** input times -- biased receiver time of receipt, t
*** input coord -- ECEF coord of a point, x,y,z (also lat/lon)
*** input range -- measured pseudorange (for rcvr. time bias), r
*** output sat clock corrected for relativity (and tgd) with bc orbit
*** version: 2006may11-11:48a

      implicit double precision(a-h,o-z)
      logical oterp,selectbc,lq2frq
      parameter(tgdave=-8.076d-9)               !*** mean tgd (sec.)
      dimension orbits(*)
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** select broadcast elements (for relativity and tgd correction)

      if(.not.selectbc(iprn,t,tsow,ierr)) then
          comrng2=.false.
          return
      else
        tsv  =djtssow(t-0.075d0)      !*** approximate tt w/ trecvr-75ms
        dtbc =bcclok1(tsv)
        dtrl =bcclok2(tsv,dtbc)       !*** relativity correction
      endif

*** iterate the light loop twice                 (confirmed-- 2004aug30)
*** dt  -- delta time (transit time -- tau)
*** tt  -- transmit time
*** dtr -- receiver time bias
*** dts -- satellite time bias
*** dtrl-- relativistic clock correction (use bc orbit)

***** dtr=0.d0      !*** this is now an input value
      dt=0.075d0
      do 1 i=1,2
        tt=(t-dtr)-dt
        if(.not.oterp(iprn,tt,orbits,xs,ys,zs,dts,ierr)) then
          comrng2=.false.
          return
        endif

        if(.not.lq2frq())             !*** IGS clock convention same as ICD
     *     dts=dts-(bctgd()-tgdave)   !*** icd200 -- 20.3.3.3.3.2
                                      !*** zero-mean GD applied per IGS/CODE

        dts=dts+dtrl       !*** relativity corrn to precise orbit/clock
                           !*** icd200 -- 20.3.3.3.3.1
        dx=xs-x
        dy=ys-y
        dz=zs-z
        s=dsqrt(dx*dx+dy*dy+dz*dz)

        dt=s/sol
*****   dtr=r/sol-dt+dts         !*** this is now an input value
    1 continue

*** now apply sagnac effect for the range
***    (icd200c -- 20.3.3.4.3.4 -- "add to pos." -or- subtract from sat.)

      sag=we*dt
      dx =xs+sag*ys-x
      dy =ys-sag*xs-y
      dz =zs       -z
      s  =dsqrt(dx*dx+dy*dy+dz*dz)

*** vert angle and azimuth in local geodetic horizon

      call rge(gla,glo, dn,de,du, dx,dy,dz)
      va=datan(du/dsqrt(dn*dn+de*de))
      az=datan2(de,dn)
      comrng2=.true.

      return
      end
************************************************************************
      subroutine geomet(orbits)

*** compute geometries
*** 2006jun10 version -- PCV corrections

      implicit double precision(a-h,o-z)
      common/lus/lst,lin,leph,lres
      logical comrng,comrng2,lqdtr4
      parameter(rnull=999999999.999d0,rnull2=999999999.d0)
      dimension orbits(*)
      parameter(mxprn=32)
      save  /dat0/,/dat1/,/dat2/
      dimension iprns(mxprn)
      common/dat0/nsat,iprns,iprnhi
      dimension r11(mxprn),p11(mxprn),r21(mxprn),p21(mxprn),s1(mxprn),
     *          dx1(mxprn),dy1(mxprn),dz1(mxprn),va1(mxprn),az1(mxprn),
     *          dts1(mxprn)
      common/dat1/t1,r11,p11,r21,p21,s1,dx1,dy1,dz1,va1,az1,dts1
      dimension r12(mxprn),p12(mxprn),r22(mxprn),p22(mxprn),s2(mxprn),
     *          dx2(mxprn),dy2(mxprn),dz2(mxprn),va2(mxprn),az2(mxprn),
     *          dts2(mxprn)
      common/dat2/t2,r12,p12,r22,p22,s2,dx2,dy2,dz2,va2,az2,dts2
      save  /dat3/
      common/dat3/dtr1a,dtr2b
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** initialize for high (pivot) sat identification

      rmin  =rnull
      iprnhi=0

*** get l2 to l1 phase center offsets  (for l2 range corrections)

      call getd12(dn121,de121,du121,dn122,de122,du122)

***   r11  pseudorange, L1, point 1
***   r12  pseudorange, L1, point 2
***   p11  phase (cy.), L1, point 1
***   p12  phase (cy.), L1, point 2
***   r21  pseudorange, L2, point 1
***   r22  pseudorange, L2, point 2
***   p21  phase (cy.), L2, point 1
***   p22  phase (cy.), L2, point 2

      do 100 iloop=1,nsat
        i=iprns(iloop)
***
*** use precomputed receiver bias (not pseudorange) ********************
***
        if(lqdtr4()) then
          dtr1=dtr1a
          dtr2=dtr2b

*** point 1

          call getl11 (x,y,z)
          call getl11g(gla,glo,eht)
          if(.not.comrng2(i,orbits,t1,x,y,z,gla,glo,dtr1,s1(i),
     *                  dx1(i),dy1(i),dz1(i),va1(i),az1(i),dts1(i)))then
            s1(i)=0.d0

*** orbit ok -- test for high sat (as pivot sat support)

          else
            if(r11(i).lt.rmin) then
              rmin  =r11(i)
              iprnhi=i
            endif

*** add geometric range corrector to l2 obs at point 1
*** cf. "geometrical calibration term", eq.(4) and eqs.(1), pg. 10188
*** blewitt, "carrier phase ambiguity...", jgr 94(b8), 10187-10203, 10-aug-89

            dp12= -dcos(va1(i))*(de121*dsin(az1(i))+dn121*dcos(az1(i)))
     *            -du121*dsin(va1(i))
            if(r21(i).lt.rnull2) r21(i)=r21(i) + dp12
            if(p21(i).lt.rnull2) p21(i)=p21(i) + dp12/w2

*** subtract rcr. phase center variation from l1 and l2 obs. at point 1
*** (1st number-frequency, 2nd number-station)

            call antint(i,1,a11,a21)
            if(r11(i).lt.rnull2) r11(i)=r11(i) - a11
            if(p11(i).lt.rnull2) p11(i)=p11(i) - a11/w1
            if(r21(i).lt.rnull2) r21(i)=r21(i) - a21
            if(p21(i).lt.rnull2) p21(i)=p21(i) - a21/w2
          endif

*** point 2   (do not use for pivot sat support) -----------------------

          call getl12 (x,y,z)
          call getl12g(gla,glo,eht)

          if(.not.comrng2(i,orbits,t2,x,y,z,gla,glo,dtr2,s2(i),
     *                  dx2(i),dy2(i),dz2(i),va2(i),az2(i),dts2(i)))then
            s2(i)=0.d0

*** apply geometric range corrector to l2 obs at point 2

          else
            dp12= -dcos(va2(i))*(de122*dsin(az2(i))+dn122*dcos(az2(i)))
     *            -du122*dsin(va2(i))
            if(r22(i).lt.rnull2) r22(i)=r22(i) + dp12
            if(p22(i).lt.rnull2) p22(i)=p22(i) + dp12/w2

*** subtract rcr. phase center variation from l1 and l2 obs. at point 2
*** (1st number-frequency, 2nd number-station)

            call antint(i,2,a12,a22)
            if(r12(i).lt.rnull2) r12(i)=r12(i) - a12
            if(p12(i).lt.rnull2) p12(i)=p12(i) - a12/w1
            if(r22(i).lt.rnull2) r22(i)=r22(i) - a22
            if(p22(i).lt.rnull2) p22(i)=p22(i) - a22/w2
          endif

************************************************************************
*** use pseudorange for receiver bias **********************************
************************************************************************
        else

*** point 1

          call getl11 (x,y,z)
          call getl11g(gla,glo,eht)
          if(.not.comrng(i,orbits,t1,x,y,z,gla,glo,r11(i),s1(i),
     *                  dx1(i),dy1(i),dz1(i),va1(i),az1(i),dts1(i)))then
            s1(i)=0.d0

*** orbit ok -- test for high sat (as pivot sat support)

          else
            if(r11(i).lt.rmin) then
              rmin  =r11(i)
              iprnhi=i
            endif

*** add geometric range corrector to l2 obs at point 1
*** cf. "geometrical calibration term", eq.(4) and eqs.(1), pg. 10188
*** blewitt, "carrier phase ambiguity...", jgr 94(b8), 10187-10203, 10-aug-89

            dp12= -dcos(va1(i))*(de121*dsin(az1(i))+dn121*dcos(az1(i)))
     *            -du121*dsin(va1(i))
            if(r21(i).lt.rnull2) r21(i)=r21(i) + dp12
            if(p21(i).lt.rnull2) p21(i)=p21(i) + dp12/w2

*** subtract rcr. phase center variation from l1 and l2 obs. at point 1
*** (1st number-frequency, 2nd number-station)

            call antint(i,1,a11,a21)
            if(r11(i).lt.rnull2) r11(i)=r11(i) - a11
            if(p11(i).lt.rnull2) p11(i)=p11(i) - a11/w1
            if(r21(i).lt.rnull2) r21(i)=r21(i) - a21
            if(p21(i).lt.rnull2) p21(i)=p21(i) - a21/w2
          endif

*** point 2   (do not use for pivot sat support) -----------------------

          call getl12 (x,y,z)
          call getl12g(gla,glo,eht)

          if(.not.comrng(i,orbits,t2,x,y,z,gla,glo,r12(i),s2(i),
     *                  dx2(i),dy2(i),dz2(i),va2(i),az2(i),dts2(i)))then
            s2(i)=0.d0

*** apply geometric range corrector to l2 obs at point 2

          else
            dp12= -dcos(va2(i))*(de122*dsin(az2(i))+dn122*dcos(az2(i)))
     *            -du122*dsin(va2(i))
            if(r22(i).lt.rnull2) r22(i)=r22(i) + dp12
            if(p22(i).lt.rnull2) p22(i)=p22(i) + dp12/w2

*** subtract rcr. phase center variation from l1 and l2 obs. at point 2
*** (1st number-frequency, 2nd number-station)

            call antint(i,2,a12,a22)
            if(r12(i).lt.rnull2) r12(i)=r12(i) - a12
            if(p12(i).lt.rnull2) p12(i)=p12(i) - a12/w1
            if(r22(i).lt.rnull2) r22(i)=r22(i) - a22
            if(p22(i).lt.rnull2) p22(i)=p22(i) - a22/w2
          endif

***
*** end of pseudorange/receiver clock bias clause **********************
***
        endif

**** end of loop over satellites with data

  100 continue

      return
      end
      subroutine antint(iprn,ista,a1,a2)

*** interpolate PCV correction (meters)

*** subtract value from observered range/phase
*** output: 1st number-frequency, 2nd number-station
*** note: table is descending in mm. (not ascending)

      implicit double precision(a-h,o-z)
*---------------------------------------------------
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,        !*** point 1
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,        !*** point 2
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt
*---------------------------------------------------
      parameter(mxprn=32)
      save  /dat0/,/dat1/,/dat2/
      dimension iprns(mxprn)
      common/dat0/nsat,iprns,iprnhi
      dimension r11(mxprn),p11(mxprn),r21(mxprn),p21(mxprn),s1(mxprn),
     *          dx1(mxprn),dy1(mxprn),dz1(mxprn),va1(mxprn),az1(mxprn),
     *          dts1(mxprn)
      common/dat1/t1,r11,p11,r21,p21,s1,dx1,dy1,dz1,va1,az1,dts1
      dimension r12(mxprn),p12(mxprn),r22(mxprn),p22(mxprn),s2(mxprn),
     *          dx2(mxprn),dy2(mxprn),dz2(mxprn),va2(mxprn),az2(mxprn),
     *          dts2(mxprn)
      common/dat2/t2,r12,p12,r22,p22,s2,dx2,dy2,dz2,va2,az2,dts2
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

      if(iprn.lt.1.or.iprn.gt.mxprn) stop 89088
      if(ista.lt.1.or.ista.gt.    2) stop 89089

*** point 1

      if(ista.eq.1) then
        vd=va1(iprn)*rad          !*** vertical angle in degrees
        i=vd/5.d0                 !*** truncate
        rmdr=vd-5*i               !*** remainder
        if(i.lt.0) then
          a1=tena1(1,19)
          a2=tena1(2,19)
          go to 10000
        endif
        if(i.ge.18) then
          a1=tena1(1,1)
          a2=tena1(2,1)
          go to 10000
        endif
        j=19-i                    !*** map [0..18] onto [19..1]
        if(rmdr.le.0.d0) then
          a1=tena1(1,j)
          a2=tena1(2,j)
          go to 10000
        endif

*** linear interpolate

        fact=rmdr/5.d0
        a1=tena1(1,j) + fact*(tena1(1,j-1)-tena1(1,j))
        a2=tena1(2,j) + fact*(tena1(2,j-1)-tena1(2,j))

*** point 2

      else
        vd2=va2(iprn)*rad          !*** vertical angle in degrees
        i=vd/5.d0                  !*** truncate
        rmdr=vd-5*i                !*** remainder
        if(i.lt. 0) then
          a1=tena2(1,1)
          a2=tena2(2,1)
          go to 10000
        endif
        if(i.ge.18) then
          a1=tena2(1,19)
          a2=tena2(2,19)
          go to 10000
        endif
        j=19-i                    !*** map [0..18] onto [19..1]
        if(rmdr.le.0.d0) then
          a1=tena2(1,j)
          a2=tena2(2,j)
          go to 10000
        endif

*** linear interpolate

        fact=rmdr/5.d0
        a1=tena2(1,j) + fact*(tena2(1,j-1)-tena2(1,j))
        a2=tena2(2,j) + fact*(tena2(2,j-1)-tena2(2,j))
      endif

*** convert table mm. to output in meters (m.)

10000 a1=a1/1000.d0
      a2=a2/1000.d0

      return
      end
************************************************************************
****** bookkeeping stuff ***********************************************
************************************************************************
      logical function getepch(delt)

*** read an epoch of data

      implicit double precision(a-h,o-z)
      common/lus/lst,lin,leph,lres
      parameter(rnull=999999999.999d0,rnull2=999999999.d0)
      parameter(mxprn=32)
      save  /dat0/,/dat1/,/dat2/
      dimension iprns(mxprn)
      common/dat0/nsat,iprns,iprnhi
      dimension r11(mxprn),p11(mxprn),r21(mxprn),p21(mxprn),s1(mxprn),
     *          dx1(mxprn),dy1(mxprn),dz1(mxprn),va1(mxprn),az1(mxprn),
     *          dts1(mxprn)
      common/dat1/t1,r11,p11,r21,p21,s1,dx1,dy1,dz1,va1,az1,dts1
      dimension r12(mxprn),p12(mxprn),r22(mxprn),p22(mxprn),s2(mxprn),
     *          dx2(mxprn),dy2(mxprn),dz2(mxprn),va2(mxprn),az2(mxprn),
     *          dts2(mxprn)
      common/dat2/t2,r12,p12,r22,p22,s2,dx2,dy2,dz2,va2,az2,dts2
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** read epoch header

      read(lin,*,end=10000) t1,t2,nsat
      if(nsat.le.0.or.nsat.gt.mxprn) stop 84343

*** compute receiver clock correction (dtr) to nearest epoch
*** this is just for subsequent data correction (below)

      if(lqprec()) then
        targ1=delt*idnint(t1/delt)
        targ2=delt*idnint(t2/delt)
        dtr1=t1-targ1
        dtr2=t2-targ2
        t1=targ1
        t2=targ2
      endif

*** load data

***   r11  pseudorange, L1, point 1
***   r12  pseudorange, L1, point 2
***   p11  phase (cy.), L1, point 1
***   p12  phase (cy.), L1, point 2
***   r21  pseudorange, L2, point 1
***   r22  pseudorange, L2, point 2
***   p21  phase (cy.), L2, point 1
***   p22  phase (cy.), L2, point 2

      do 100 iloop=1,nsat
        read(lin,1) i, r1a,r1b, p1a,p1b, r2a,r2b, p2a,p2b
    1   format(i2, 2f13.3,2f14.3, 2f13.3,2f14.3)

*** stick into common block arrays,  (i = prn)
*** special note -- indexing to straight iprn!!!!!!!!!!!!!!!!

        iprns(iloop)=i

        r11(i)=r1a
        r12(i)=r1b
        p11(i)=p1a
        p12(i)=p1b
        r21(i)=r2a
        r22(i)=r2b
        p21(i)=p2a
        p22(i)=p2b

*** apply receiver clock correction to nearest epoch (c.f. RINEX2-2.TXT)
*** corrected frequency bug (of 2004aug24)

        if(lqprec()) then
          if(r11(i).lt.rnull2) r11(i)=r11(i)-dtr1*sol
          if(r21(i).lt.rnull2) r21(i)=r21(i)-dtr1*sol
          if(p11(i).lt.rnull2) p11(i)=p11(i)-dtr1*f1
          if(p21(i).lt.rnull2) p21(i)=p21(i)-dtr1*f2

          if(r12(i).lt.rnull2) r12(i)=r12(i)-dtr2*sol
          if(r22(i).lt.rnull2) r22(i)=r22(i)-dtr2*sol
          if(p12(i).lt.rnull2) p12(i)=p12(i)-dtr2*f1
          if(p22(i).lt.rnull2) p22(i)=p22(i)-dtr2*f2
        endif

**** end of loop over satellites with data

  100 continue

      getepch=.true.
      return

*** end of file -- trying to read header

10000 getepch=.false.
      return
      end
************************************************************************
****** ambiguity table stuff *******************************************
************************************************************************
      subroutine make(orbits)

*** make ambiguity table from current coordinate

      implicit double precision(a-h,o-z)
      logical getepch
      parameter(mxprn=32,mxepch=192)
      dimension orbits(mxepch + 4*mxprn*mxepch)
      common/lus/lst,lin,leph,lres
      save  /tlimit/
      common/tlimit/nloop,nloopmx

      call mrhead2                             !*** position file
      call ini                                 !*** initialize ambiguity table

*** accumulate ambiguities

      do iloop=1,nloopmx
        if(.not.getepch(dlt)) go to 700               !*** read data file
        call geomet(orbits)                           !*** solve geometry
        call ddmake
      enddo
  700 continue

      return
      end
      subroutine ddmake

*** accumulate ambiguity entries for an epoch of DD phase

      implicit double precision(a-h,o-z)
      logical afirst,tadd,get,lqhalf
      parameter(deltf=0.3d0,delth=0.15d0)      !*** units of cycles
      parameter(mxprn=32)
      parameter(rnull2=999999999.d0,tiny=1.d-2)
      save  /dat0/,/dat1/,/dat2/
      dimension iprns(mxprn)
      common/dat0/nsat,iprns,iprnhi
      dimension r11(mxprn),p11(mxprn),r21(mxprn),p21(mxprn),s1(mxprn),
     *          dx1(mxprn),dy1(mxprn),dz1(mxprn),va1(mxprn),az1(mxprn),
     *          dts1(mxprn)
      common/dat1/t1,r11,p11,r21,p21,s1,dx1,dy1,dz1,va1,az1,dts1
      dimension r12(mxprn),p12(mxprn),r22(mxprn),p22(mxprn),s2(mxprn),
     *          dx2(mxprn),dy2(mxprn),dz2(mxprn),va2(mxprn),az2(mxprn),
     *          dts2(mxprn)
      common/dat2/t2,r12,p12,r22,p22,s2,dx2,dy2,dz2,va2,az2,dts2
      common/lus/lst,lin,leph,lres
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we
      save  /atab2/
      dimension axs(mxprn)
      common/atab2/axs

*** r-range, p-phase, s-model, 1st number-frequency, 2nd number-station

*** first differences (between stations) (for high sat)

      if(p11(iprnhi).gt.rnull2.or.s1(iprnhi).lt.tiny) return
      if(p12(iprnhi).gt.rnull2.or.s2(iprnhi).lt.tiny) return
      dphi=p12(iprnhi)-p11(iprnhi)
      dshi= s2(iprnhi)- s1(iprnhi)

      do 100 iloop=1,nsat
        i=iprns(iloop)                       !*** prn of the measurement
        if(i.eq.iprnhi) go to 100
        if(p11(i).gt.rnull2.or.s1(i).lt.tiny) go to 100
        if(p12(i).gt.rnull2.or.s2(i).lt.tiny) go to 100

        dplo=p12(i)-p11(i)
        dslo= s2(i)- s1(i)

        ddp = dplo-dphi                      !*** units of phase (cycle)
        dds = dslo-dshi
        omc = ddp-dds/w1                     !*** units of phase (cycle)
        if(lqhalf()) then
          omca =dble(idnint(2.d0*omc))/2.d0         !*** half-wavelength
          delta=delth
        else
          omca =dble(idnint(omc))                   !*** full-wavelength
          delta=deltf
        endif

        if(afirst(i)) then
          if(.not.tadd(t1,i,idx)) stop 34983        !*** new sat
        else
          if(dabs(omc-axs(i)).gt.delta) then        !*** jump in ambiguity
            if(.not.tadd(t1,i,idx)) stop 34984
          else
            if(.not.get(t1,i,idx)) stop 34985
          endif
        endif
        call aput2(omca,va1(i),i,idx)               !*** store initial value
        axs(i)=omc                                  !*** last ambiguity seen
  100 continue

      return
      end
      subroutine ini

*** initialize ambiguity tables

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num
      save  /atab2/
      dimension axs(mxpr)
      common/atab2/axs

      num=0           !*** total number of entries
      mpiv=0          !*** master pivot satellite prn
      do i=1,mxpr
        nt(i)=0       !*** number of time entries for each prn
        axs(i)=0.d0   !*** initial value of ambiguities (cycles)
      enddo

      return
      end
      integer function nsize()

*** how many ambiguities?

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num

      nsize=num

      return
      end
      double precision function aget(i)

*** get an ambiguity (float)

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num

      if(i.le.0.or.i.gt.num) stop 88448
      aget=as(i)                          !*** just a fancy array lookup

      return
      end
      subroutine aput(amb,i)

*** store an ambiguity (float)

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num

      if(i.le.0.or.i.gt.num) stop 88449
      as(i)=amb                           !*** just a fancy array update

      return
      end
      subroutine aput2(amb,va,ilo,i)

*** store an ambiguity -- only if higher angle

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num

      if(i.le.0.or.i.gt.num) stop 88459
      if(va.gt.vs(ilo)) then              !*** keep entry w/highest v.a.
        as(i)  =amb
        vs(ilo)=va
      endif

      return
      end
      logical function afirst(ilo)

*** test if first entry for a satellite, ilo

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num

      if(nt(ilo).le.0) then
        afirst=.true.
      else
        afirst=.false.
      endif

      return
      end
      logical function tadd(t,ilo,nout)

*** add an index (and time) to the ambiguity table

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num

      n=nt(ilo)+1                    !*** increment and do tests
      if(n.gt.mxt) then
        tadd=.false.
        return
      endif

      if(n.ge.2) then                 !*** multiple entries?
        if(t.le.ts(ilo,n-1)) then     !*** non-ascending time?
          tadd=.false.
          return
        endif
      endif

      num        =num+1               !*** new total is new index
      nt(ilo)    =n                   !*** incremented above
      idxs(ilo,n)=num                 !*** store the new index
      ts  (ilo,n)=t                   !*** store the new time
      vs  (ilo)  =0.d0                !*** set/reset vert.angle for tests
      nout       =num                 !*** return the new index
      tadd        =.true.             !*** OK

      return
      end
      logical function get(t,ilo,idx)

*** look up ambiguity index

      implicit double precision(a-h,o-z)
      parameter(ep=0.1d0,mxpr=32,mxt=101,nax=mxpr*mxt)
      save  /atab/
      dimension ts(mxpr,mxt),as(nax),vs(mxpr),nt(mxpr),idxs(mxpr,mxt)
      common/atab/ts,as,vs,nt,idxs,mpiv,num

      n=nt(ilo)                       !*** number of times for this sat
      if(n.le.0) then                 !*** no entries for this satellite
        idx=0
        get=.false.
        return
      endif

      tep=t+ep                        !*** epsilon allows clock drift, etc...
      if(tep.lt.ts(ilo,1)) then       !*** input time too early
        idx=0
        get=.false.
        return
      endif

      if(n.eq.1) then                 !*** just one time for this sat.
        idx=idxs(ilo,1)
        get=.true.
        return
      endif

*** loop thru the times for this satellite

      do i=1,n-1
        if(tep.ge.ts(ilo,i).and.tep.lt.ts(ilo,i+1)) then
          idx=idxs(ilo,i)
          get=.true.
          return
        endif
      enddo

*** if fell thru the loop, use last time entry

      idx=idxs(ilo,n)
      get=.true.

      return
      end
************************************************************************
*** header data routines ***********************************************
************************************************************************
      subroutine mrhead2

*** rewind/bypass merge file header

      implicit double precision(a-h,o-z)
      common/lus/lst,lin,leph,lres

      rewind(lin)
      do i=1,14
        read(lin,*)
      enddo

      return
      end
      subroutine mrhead

*** read merge file header

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      common/stugg/pi,rad,sol,f1,f2,w1,w2,we
      common/lus/lst,lin,leph,lres

      read(lin,*)                 iyr,imo,idy
    1 format(a4,12x,5f14.4,f10.4)
    2 format(4x,12x,5f14.4,f10.4)
      read(lin,1) aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1
      read(lin,2)      xar1,yar1,zar1,gar1,gor1,ehr1
      read(lin,2)      xl11,yl11,zl11,ga11,go11,eh11
      read(lin,2)      xl21,yl21,zl21,ga21,go21,eh21
      read(lin,'(19f5.1)')        (tena1(1,i),i=1,19)
      read(lin,'(19f5.1)')        (tena1(2,i),i=1,19)
      read(lin,1) aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2
      read(lin,2)      xar2,yar2,zar2,gar2,gor2,ehr2
      read(lin,2)      xl12,yl12,zl12,ga12,go12,eh12
      read(lin,2)      xl22,yl22,zl22,ga22,go22,eh22
      read(lin,'(19f5.1)')        (tena2(1,i),i=1,19)
      read(lin,'(19f5.1)')        (tena2(2,i),i=1,19)
      read(lin,*)                 tmin,tmax,delt

*** convert lat/long to radians

      gak1=gak1/rad
      gok1=gok1/rad
      gar1=gar1/rad
      gor1=gor1/rad
      ga11=ga11/rad
      go11=go11/rad
      ga21=ga21/rad
      go21=go21/rad

      gak2=gak2/rad
      gok2=gok2/rad
      gar2=gar2/rad
      gor2=gor2/rad
      ga12=ga12/rad
      go12=go12/rad
      ga22=ga22/rad
      go22=go22/rad

*** initialize time handler

      call setjd0(iyr,imo,idy)
      write(lst,'(''yr,mo,dy = '',i4,2i3)') iyr,imo,idy

*** get l2 to l1 offsets in geodetic horizon (of l1 center)

      dx=xl11-xl21
      dy=yl11-yl21
      dz=zl11-zl21
      call rge(ga11,go11, dn121,de121,du121, dx,dy,dz)

      dx=xl12-xl22
      dy=yl12-yl22
      dz=zl12-zl22
      call rge(ga12,go12, dn122,de122,du122, dx,dy,dz)

*** clone the original coordinates for mark, point 2

      call cclone

      return
      end
      subroutine mrhdump

*** dump some info from the merge file header

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      common/stugg/pi,rad,sol,f1,f2,w1,w2,we
      common/lus/lst,lin,leph,lres

      write(lst,'(a,2f10.2,f7.2,i6)') 'data strt/stop,delt       ',
     *                                 tmin,tmax,delt

      call todms(ga11*rad,idla,imla,sla)
      call todms(go11*rad,idlo,imlo,slo)

      write(lst,'(a,a,2i3.2,f9.5,i7,i3.2,f9.5,f12.4)') aid1,' L1PC   ',
     *    idla,imla,sla,idlo,imlo,slo,eh11

      call todms(gar1*rad,idla,imla,sla)
      call todms(gor1*rad,idlo,imlo,slo)

      write(lst,'(a,a,2i3.2,f9.5,i7,i3.2,f9.5,f12.4)') aid1,' ARP    ',
     *    idla,imla,sla,idlo,imlo,slo,ehr1

      call todms(gak1*rad,idla,imla,sla)
      call todms(gok1*rad,idlo,imlo,slo)

      write(lst,'(a,a,2i3.2,f9.5,i7,i3.2,f9.5,f12.4)') aid1,' MARK   ',
     *    idla,imla,sla,idlo,imlo,slo,ehk1

      blm=dsqrt((xl12-xl11)*(xl12-xl11) + 
     *          (yl12-yl11)*(yl12-yl11) + 
     *          (zl12-zl11)*(zl12-zl11))
      thr=(tmax-tmin)/3600.d0
      write(lst,'(3a4,a,f11.2,a,f6.2,a)') aid1,' to ',aid2,
     *    ' -- base=',blm,' m.     interval =',thr,' hr'

      call getl12g(ga12,go12,eh12)
      call getmk2g(gak2,gok2,ehk2)

      write(lst,'(a,a,f12.4)') aid2,
     *     ' DELTA HT.  (L1PC-MARK)', (eh12-ehk2)

      return
      end
      subroutine todms(deg,id,im,sec)

*** convert decimal degree to dms

      implicit double precision(a-h,o-z)

      val=dabs(deg)
      if(val.gt.180.d0) val=360.d0-val
      id=val
      val=(val-id)*60.d0
      im=val
      sec=(val-im)*60.d0

      return
      end
      subroutine update(x,namb)

*** apply lsq corrections to rover coordinate set
*** sense of sign matches a cmo misclosure

      implicit double precision(a-h,o-z)
      logical xyzgeo
      parameter(mxpr=32,mxt=101,mxx=mxpr*mxt+3)
      dimension x(mxx)
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** ambiguities

      do i=1,namb
        call aput( (aget(i)-x(i)) ,i)
      enddo

*** mark

      call getmk2(x0,y0,z0)
      xp=x0-x(namb+1)
      yp=y0-x(namb+2)
      zp=z0-x(namb+3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77586
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putmk2(xp,yp,zp)
      call putmk2g(gla,glo,eht)

*** arp

      call getarp2(x0,y0,z0)
      xp=x0-x(namb+1)
      yp=y0-x(namb+2)
      zp=z0-x(namb+3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77587
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putarp2(xp,yp,zp)
      call putarp2g(gla,glo,eht)

*** l1 phase center

      call getl12(x0,y0,z0)
      xp=x0-x(namb+1)
      yp=y0-x(namb+2)
      zp=z0-x(namb+3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77588
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putl12(xp,yp,zp)
      call putl12g(gla,glo,eht)

*** l2 phase center

      call getl22(x0,y0,z0)
      xp=x0-x(namb+1)
      yp=y0-x(namb+2)
      zp=z0-x(namb+3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77589
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putl22(xp,yp,zp)
      call putl22g(gla,glo,eht)

      return
      end
      subroutine update2(x)

*** apply lsq corrections to rover coordinate set
*** sense of sign matches a cmo misclosure

      implicit double precision(a-h,o-z)
      logical xyzgeo
      parameter(mxx=3)
      dimension x(mxx)
      common/stugg/pi,rad,sol,f1,f2,w1,w2,we

*** mark

      call getmk2(x0,y0,z0)
      xp=x0-x(1)
      yp=y0-x(2)
      zp=z0-x(3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77586
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putmk2(xp,yp,zp)
      call putmk2g(gla,glo,eht)

*** arp

      call getarp2(x0,y0,z0)
      xp=x0-x(1)
      yp=y0-x(2)
      zp=z0-x(3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77587
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putarp2(xp,yp,zp)
      call putarp2g(gla,glo,eht)

*** l1 phase center

      call getl12(x0,y0,z0)
      xp=x0-x(1)
      yp=y0-x(2)
      zp=z0-x(3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77588
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putl12(xp,yp,zp)
      call putl12g(gla,glo,eht)

*** l2 phase center

      call getl22(x0,y0,z0)
      xp=x0-x(1)
      yp=y0-x(2)
      zp=z0-x(3)
      if(.not.xyzgeo(xp,yp,zp,gla,glo,eht)) stop 77589
      if(glo.lt.0.d0) glo=glo+pi+pi
      call putl22(xp,yp,zp)
      call putl22g(gla,glo,eht)

      return
      end
      character*4 function pnam1()

*** return point 1 name

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      pnam1=aid1

      return
      end
      character*4 function pnam2()

*** return point 2 name

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      pnam2=aid2

      return
      end
      subroutine getmk1(x,y,z)

*** return mark point 1

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xmk1
      y=ymk1
      z=zmk1

      return
      end
      subroutine getmk2(x,y,z)

*** return mark point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xmk2
      y=ymk2
      z=zmk2

      return
      end
      subroutine getarp1(x,y,z)

*** return arp point 1

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xar1
      y=yar1
      z=zar1

      return
      end
      subroutine getarp2(x,y,z)

*** return arp point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xar2
      y=yar2
      z=zar2

      return
      end
      subroutine getl11(x,y,z)

*** return l1 phase center point 1

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xl11
      y=yl11
      z=zl11

      return
      end
      subroutine getl12(x,y,z)

*** return l1 phase center point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xl12
      y=yl12
      z=zl12

      return
      end
      subroutine getl21(x,y,z)

*** return l2 phase center point 1

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xl21
      y=yl21
      z=zl21

      return
      end
      subroutine getl22(x,y,z)

*** return l2 phase center point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      x=xl22
      y=yl22
      z=zl22

      return
      end
      subroutine getmk1g(gla,glo,eht)

*** return mark point 1 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=gak1
      glo=gok1
      eht=ehk1

      return
      end
      subroutine getmk2g(gla,glo,eht)

*** return mark point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=gak2
      glo=gok2
      eht=ehk2

      return
      end
      subroutine getarp1g(gla,glo,eht)

*** return arp point 1 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=gar1
      glo=gor1
      eht=ehr1

      return
      end
      subroutine getarp2g(gla,glo,eht)

*** return arp point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=gar2
      glo=gor2
      eht=ehr2

      return
      end
      subroutine getl11g(gla,glo,eht)

*** return l1 phase center point 1 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=ga11
      glo=go11
      eht=eh11

      return
      end
      subroutine getl12g(gla,glo,eht)

*** return l1 phase center point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=ga12
      glo=go12
      eht=eh12

      return
      end
      subroutine getl21g(gla,glo,eht)

*** return l2 phase center point 1 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=ga21
      glo=go21
      eht=eh21

      return
      end
      subroutine getl22g(gla,glo,eht)

*** return l2 phase center point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gla=ga22
      glo=go22
      eht=eh22

      return
      end
      subroutine getd12(dn1,de1,du1,dn2,de2,du2)

*** return l2 to l1 phase center differences

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      dn1=dn121
      de1=de121
      du1=du121

      dn2=dn122
      de2=de122
      du2=du122

      return
      end
      subroutine gettsuf(tmn,tmx,dlt)

*** return time stuff

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      tmn=tmin
      tmx=tmax
      dlt=delt

      return
      end
      subroutine putmk2(x,y,z)

*** store mark point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      xmk2=x
      ymk2=y
      zmk2=z

      return
      end
      subroutine putarp2(x,y,z)

*** store arp point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      xar2=x
      yar2=y
      zar2=z

      return
      end
      subroutine putl12(x,y,z)

*** store l1 phase center point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      xl12=x
      yl12=y
      zl12=z

      return
      end
      subroutine putl22(x,y,z)

*** store l2 phase center point 2

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      xl22=x
      yl22=y
      zl22=z

      return
      end
      subroutine putmk2g(gla,glo,eht)

*** store mark point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gak2=gla
      gok2=glo
      ehk2=eht

      return
      end
      subroutine putarp2g(gla,glo,eht)

*** store arp point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      gar2=gla
      gor2=glo
      ehr2=eht

      return
      end
      subroutine putl12g(gla,glo,eht)

*** store l1 phase center point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      ga12=gla
      go12=glo
      eh12=eht

      return
      end
      subroutine putl22g(gla,glo,eht)

*** store l2 phase center point 2 -- geodetic

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      ga22=gla
      go22=glo
      eh22=eht

      return
      end
      subroutine cclone

*** clone point 2 mark coordinates

      implicit double precision(a-h,o-z)
      character*4 aid1,aid2
      dimension tena1(2,19),tena2(2,19)
      save  /hdr/
      common/hdr/iyr,imo,idy,
     *           aid1,xmk1,ymk1,zmk1,gak1,gok1,ehk1,
     *                xar1,yar1,zar1,gar1,gor1,ehr1,
     *                xl11,yl11,zl11,ga11,go11,eh11,
     *                xl21,yl21,zl21,ga21,go21,eh21,
     *           tena1,dn121,de121,du121,
     *           aid2,xmk2,ymk2,zmk2,gak2,gok2,ehk2,
     *                xar2,yar2,zar2,gar2,gor2,ehr2,
     *                xl12,yl12,zl12,ga12,go12,eh12,
     *                xl22,yl22,zl22,ga22,go22,eh22,
     *           tena2,dn122,de122,du122,
     *           tmin,tmax,delt

      save  /clo/
      common/clo/xmk2o,ymk2o,zmk2o,gak2o,gok2o,ehk2o

      xmk2o=xmk2
      ymk2o=ymk2
      zmk2o=zmk2
      gak2o=gak2
      gok2o=gok2
      ehk2o=ehk2

      return
      end
      subroutine getomk2(x,y,z)

*** return original mark point 2

      implicit double precision(a-h,o-z)

      save  /clo/
      common/clo/xmk2o,ymk2o,zmk2o,gak2o,gok2o,ehk2o

      x=xmk2o
      y=ymk2o
      z=zmk2o

      return
      end
      subroutine getomk2g(gla,glo,eht)

*** return original mark point 2 -- geodetic

      implicit double precision(a-h,o-z)

      save  /clo/
      common/clo/xmk2o,ymk2o,zmk2o,gak2o,gok2o,ehk2o

      gla=gak2o
      glo=gok2o
      eht=ehk2o

      return
      end
************************************************************************
*** geodesy utilities **************************************************
************************************************************************
      subroutine geoxyz(gla,glo,eht,x,y,z)
 
*** convert geodetic lat, long, ellip ht. to x,y,z
*** input units of radians, output in meters
******NOTE: e2 is from wgs84  ***********CHECK THIS
 
      implicit double precision(a-h,o-z)
      parameter(a=6378137.d0,e2=0.00669437999013d0)
 
      sla=dsin(gla)
      cla=dcos(gla)
      w2=1.d0-e2*sla*sla
      w=dsqrt(w2)
      en=a/w
 
      x=(en+eht)*cla*dcos(glo)
      y=(en+eht)*cla*dsin(glo)
      z=(en*(1.d0-e2)+eht)*sla
 
      return
      end
      logical function xyzgeo(x,y,z,glat,glon,eht)
 
*** convert x,y,z into geodetic lat, lon, and ellip. ht
*** input units of meters, output in radians
******NOTE: e2 is from wgs84  ***********CHECK THIS
*** ref: eq a.4b, p. 132, appendix a, osu #370
*** ref: geom geod notes gs 658, rapp
 
      implicit double precision(a-h,o-z)
      parameter(maxint=10,tol=5.d-15)
      parameter(a=6378137.d0,e2=0.00669437999013d0)
 
      ae2=a*e2
 
*** compute initial estimate of reduced latitude  (eht=0)
 
      p=dsqrt(x*x+y*y)
      icount=0
      tgla=z/p/(1.d0-e2)
 
*** iterate to convergence, or to max # iterations
 
    1 if(icount.le.maxint) then
        tglax=tgla
        tgla=z/(p-(ae2/dsqrt(1.d0+(1.d0-e2)*tgla*tgla)))
        icount=icount+1
        if(dabs((tgla-tglax)/tgla).gt.tol) go to 1
 
*** convergence achieved
 
        xyzgeo=.true.
        glat=datan(tgla)
        slat=dsin(glat)
        clat=dcos(glat)
        glon=datan2(y,x)
        w=dsqrt(1.d0-e2*slat*slat)
        en=a/w
        if(dabs(glat).le.0.7854d0) then
          eht=p/clat-en
        else
          eht=z/slat-en+e2*en
        endif
        glon=datan2(y,x)
 
*** too many iterations
 
      else
        xyzgeo=.false.
        glat=0.d0
        glon=0.d0
        eht=0.d0
      endif
 
      return
      end
      subroutine rge(gla,glo,u,v,w,x,y,z)

*** given a rectangular cartesian system (x,y,z)
*** compute a geodetic h cartesian sys   (u,v,w)

      implicit double precision(a-h,o-z)

      sb=dsin(gla)
      cb=dcos(gla)
      sl=dsin(glo)
      cl=dcos(glo)

      u=-sb*cl*x-sb*sl*y+cb*z
      v=-   sl*x+   cl*y
      w= cb*cl*x+cb*sl*y+sb*z

      return
      end
************************************************************************
*** broadcast orbit support ********************************************
*** 2004 august 28 version *********************************************
************************************************************************

*** icd200block icd-gps-200c + irn-200c-002 97sep25
***   parameter(gm   = 3.986005d14)                     !*** 20.3.3.3.3.1
***   parameter(we   = 7.2921151467d-5) !*** rad/sec    !*** table 20-IV
***   parameter(gpspi= 3.1415926535898d0)               !*** 20.3.3.4.3.2
***   parameter(sol  = 299792458.d0)                    !*** 20.3.4.3
***   parameter(bigf =-4.442807633d-10) !*** sec/m**0.5 !*** 20.3.3.3.3.1

      subroutine blodorb

*** read rinex navigation file -- in "leph"

      implicit double precision(a-h,o-z)
      character*80 card
      parameter(nbc=30,mxprn=32,mxtrw=48)     !*** mxtrw=time rows (2-3 days)
      dimension bf(nbc)                       !*** buffer for nav elements
      dimension allbc(nbc,mxprn,mxtrw),nepbc(mxprn)
      save  /bcalla/
      common/bcalla/allbc,nepbc
      dimension     bcalfa(4),bcbeta(4)
      save  /bcionc/
      common/bcionc/bcalfa,bcbeta
      common/lus/lst,lin,leph,lres

*** initialize # epochs/sat counters

      do i=1,mxprn
        nepbc(i)=0
      enddo

*** initialize bc iono

      do i=1,4
        bcalfa(i)=0.d0
        bcbeta(i)=0.d0
      enddo

*** header (and iono, if any)

    1 read(leph,'(a80)') card
      if(card(61:73).ne.'END OF HEADER') then
        if(    card(61:69).eq.'ION ALPHA') then
          read(card,'(2x,4d12.4)') (bcalfa(i),i=1,4)
        elseif(card(61:68).eq.'ION BETA') then
          read(card,'(2x,4d12.4)') (bcbeta(i),i=1,4)
        endif
        go to 1
      endif

*** body (a leader followed by 7)

    2 read(leph,'(i2,5i3,f5.1,3d19.12)',end=777)
     *    iprn,iyr,imo,idy,ihr,imn,sec,af0,af1,af2

      read(leph,'(3x,4d19.12)') diode  ,crs   ,deln ,em0
      read(leph,'(3x,4d19.12)') cuc    ,e     ,cus  ,sqrta
      read(leph,'(3x,4d19.12)') t0e    ,cic   ,omg0 ,cis
      read(leph,'(3x,4d19.12)') eye0   ,crc   ,w    ,omgdot
      read(leph,'(3x,4d19.12)') eyedot ,dl2cd ,wkno ,dl2pd
      read(leph,'(3x,4d19.12)') svac   ,svhl  ,tgd  ,diodc
      read(leph,'(3x, d19.12)') tot

*** massage the epoch (time of clock, t0c)

      if    (iyr.lt.80) then
        iyr=iyr+2000                        !*** y2k
      elseif(iyr.le.99) then
        iyr=iyr+1900                        !*** fail 2080
      else
        stop 93482                          !*** impossible to get here
      endif

      call civjts(iyr,imo,idy,ihr,imn,sec,djts) !*** also used for the index
      t0c=djtssow(djts)

*** transfer all to buffer

      bf( 1)= djts    !***  my time for lookup index

*** clock parameters

      bf( 2)= t0c     !***  clock corrector reference epoch            (s)
      bf( 3)= af0     !***  clock offset                               (s)
      bf( 4)= af1     !***  clock error rate                          (s/s)
      bf( 5)= af2     !***  clock error accelleration              (s/(s*s))

*** kepler elements

      bf( 6)= t0e     !***  reference epoch of ephemeris             (sow)
      bf( 7)= sqrta   !***  square root of semimajor axis           sqrt(m)
      bf( 8)= e       !***  eccentricity
      bf( 9)= eye0    !***  inclination at ref. epoch                  (r)
      bf(10)= omg0    !***  right ascension of asc. node at ref. epoch (r)
      bf(11)= w       !***  argument of perigee                        (r)
      bf(12)= em0     !***  mean anomaly at ref. epoch                 (r)

*** perturbation parameters

      bf(13)= deln    !***  mean motion difference from computed value (r/s)
      bf(14)= eyedot  !***  rate of change of inclination              (r/s)
      bf(15)= omgdot  !***  rate of change of right ascension          (r/s)

      bf(16)= cuc     !***  cosine harmonic correction to arg. of lat. (r)
      bf(17)= cus     !***  sine harmonic correction to arg. of lat.   (r)
      bf(18)= crc     !***  cosine harmonic correction to radius       (m)
      bf(19)= crs     !***  sine harmonic correction to radius         (m)
      bf(20)= cic     !***  cosine harmonic correction to inclination  (r)
      bf(21)= cis     !***  sine harmonic correction to inclination    (r)

*** other data 

      bf(22)= diode   !***  issue of data ephemeris
      bf(23)= dl2cd   !***  codes on l2 channel (binary, 01-p, 10-c/a)
      bf(24)= wkno    !***  gps week # (to go with toe)               (wk)
      bf(25)= dl2pd   !***  l2 p data flag (binary, 0-norm, 1-set off)
      bf(26)= svac    !***  URA index (converted)                      (m)
      bf(27)= svhl    !***  sv health    (6 bits, 0-ok, 1-not)
      bf(28)= tgd     !***  est. group delay   (tsv-tgd)               (s)
      bf(29)= diodc   !***  issue of data clock
      bf(30)= tot     !***  transmission time of message             (sow)

*** store into data array    (test for # epoch overflow)

      if(nepbc(iprn).ge.mxtrw) then
        write(*,*) 'Array overflow in blodorb():',iprn
        stop 13483
      endif

*** load unhealthy sats (i.e. no health check)
*** logic assumes later file entries better than earlier

      if(nepbc(iprn).eq.0) then                !*** first entry for prn
        nepbc(iprn)=nepbc(iprn)+1              !*** increment epoch count
        do i=1,nbc
          allbc(i,iprn,nepbc(iprn))=bf(i)
        enddo

*** not first entry -- check for epoch proximity/updates

      else
        djtsx=allbc(01,iprn,nepbc(iprn))         !*** last jts loaded for prn
        delt=djts-djtsx
        if(    dabs(delt).le.   1.d0) then       !*** duplicate
          do i=1,nbc
            allbc(i,iprn,nepbc(iprn))=bf(i)      !*** no increment/overwrite
          enddo

        elseif(dabs(delt).ge.1800.d0) then       !*** normal update  (sec.)
          nepbc(iprn)=nepbc(iprn)+1
          do i=1,nbc
            allbc(i,iprn,nepbc(iprn))=bf(i)
          enddo

*** supress close updates (1/2 hour)

        else                                  !*** these got preempted
          continue                            !*** e.g. --> 16 sec.
        endif
      endif
      go to 2

*** end of file

  777 continue

      return
      end
************************************************************************
      logical function boterp(iprn,tsec,x,y,z,ierr)

*** wrapper to interpolate sat position from broadcast elements
*** totally modular -- can do selection distinct from sat pos comp.

      implicit double precision(a-h,o-z)
      logical selectbc,boterp2

      boterp=.false.
      if(selectbc(iprn,tsec,t,ierr)) then
        call boterp2(t,x,y,z)                     !*** compute
        boterp=.true.
      endif

      return
      end
      logical function selectbc(iprn,tsec,t,ierr)

*** find index to BC array, lookup using jts time (seconds)
*** find is nearest jts version of t0c
*** then upload the data into common and also return sow time (t)

      implicit double precision(a-h,o-z)
      parameter(nbc=30,mxprn=32,mxtrw=48)     !*** mxtrw=time rows (2-3 days)
      dimension allbc(nbc,mxprn,mxtrw),nepbc(mxprn)
      save  /bcalla/
      common/bcalla/allbc,nepbc

*** ierr=1  not currently used
*** ierr=2  prn not in orbit file
*** ierr=3  time boundary violation (not used -- extrapolation allowed)

      t   =djtssow(tsec)                   !*** to gps seconds of week

      selectbc=.false.                     !*** assume the worst
      if(nepbc(iprn).le.0) then
        ierr=2
        return
      endif

*** first check start/stop boundaries (extrapolation allowed)

      if(tsec.le.allbc(1,iprn,1)) then
        iepch=1
        call bcbfload(iprn,iepch)
        selectbc=.true.
        return
      endif

      mxepch = nepbc(iprn)
      if(tsec.ge.allbc(1,iprn,mxepch)) then
        iepch=mxepch
        call bcbfload(iprn,iepch)
        selectbc=.true.
        return
      endif

*** somewhere in-between
*** increment until upper point passes the given time

      do i=1,mxepch-1
        if(allbc(1,iprn,i+1) .ge. tsec) then
          if(dabs(tsec-allbc(1,iprn,i  )) .lt. 
     *       dabs(tsec-allbc(1,iprn,i+1))) then
            iepch=i
            call bcbfload(iprn,iepch)
            selectbc=.true.
            return
          else
            iepch=i+1
            call bcbfload(iprn,iepch)
            selectbc=.true.
            return
          endif
        endif
      enddo

*** fell thru loop -- not allowed

      stop 73345
      end
      subroutine bcbfload(ip,iep)

*** given epoch and satellite, upload data into common

      implicit double precision(a-h,o-z)
      parameter(nbc=30,mxprn=32,mxtrw=48)     !*** mxtrw=time rows (2-3 days)
      dimension bf(nbc)                       !*** buffer for nav elements
      dimension allbc(nbc,mxprn,mxtrw),nepbc(mxprn)
      save  /bcalla/
      common/bcalla/allbc,nepbc
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

      if(ip .lt.1.or.ip .gt.mxprn) stop 55447
      if(iep.lt.1.or.iep.gt.mxtrw) stop 55448
      if(iep.gt.nepbc(ip))         stop 55449

      iprn =ip
      iepch=iep

*** load buffer from master array

      do i=1,nbc
        bf(i)=allbc(i,iprn,iepch)
      enddo

*** load individual array elements from buffer

      djts   =bf( 1)  !***  my time for lookup index

*** clock parameters

      t0c    =bf( 2)  !***  clock corrector reference epoch            (s)
      af0    =bf( 3)  !***  clock offset                               (s)
      af1    =bf( 4)  !***  clock error rate                          (s/s)
      af2    =bf( 5)  !***  clock error accelleration              (s/(s*s))

*** kepler elements

      t0e    =bf( 6)  !***  reference epoch of ephemeris             (sow)
      sqrta  =bf( 7)  !***  square root of semimajor axis           sqrt(m)
      e      =bf( 8)  !***  eccentricity
      eye0   =bf( 9)  !***  inclination at ref. epoch                  (r)
      omg0   =bf(10)  !***  right ascension of asc. node at ref. epoch (r)
      w      =bf(11)  !***  argument of perigee                        (r)
      em0    =bf(12)  !***  mean anomaly at ref. epoch                 (r)

*** perturbation parameters

      deln   =bf(13)  !***  mean motion difference from computed value (r/s)
      eyedot =bf(14)  !***  rate of change of inclination              (r/s)
      omgdot =bf(15)  !***  rate of change of right ascension          (r/s)

      cuc    =bf(16)  !***  cosine harmonic correction to arg. of lat. (r)
      cus    =bf(17)  !***  sine harmonic correction to arg. of lat.   (r)
      crc    =bf(18)  !***  cosine harmonic correction to radius       (m)
      crs    =bf(19)  !***  sine harmonic correction to radius         (m)
      cic    =bf(20)  !***  cosine harmonic correction to inclination  (r)
      cis    =bf(21)  !***  sine harmonic correction to inclination    (r)

*** other data 

      diode  =bf(22)  !***  issue of data ephemeris
      dl2cd  =bf(23)  !***  codes on l2 channel (binary, 01-p, 10-c/a)
      wkno   =bf(24)  !***  gps week # (to go with toe)               (wk)
      dl2pd  =bf(25)  !***  l2 p data flag (binary, 0-norm, 1-set off)
      svac   =bf(26)  !***  URA index (converted)                      (m)
      svhl   =bf(27)  !***  sv health    (6 bits, 0-ok, 1-not)
      tgd    =bf(28)  !***  est. group delay   (tsv-tgd)               (s)
      diodc  =bf(29)  !***  issue of data clock
      tot    =bf(30)  !***  transmission time of message             (sow)

      return
      end
************************************************************************
      double precision function bcclok1(tin)
      
*** compute satellite clock correction (non-relativity term)
*** sense of the corrector is:   t=tsv-dt

      implicit double precision(a-h,o-z)
      logical lq2frq
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

      t=tin
      if((t-t0c).gt. 302400.d0 ) t=t-604800.d0     !*** handle week rollover
      if((t-t0c).lt.-302400.d0 ) t=t+604800.d0     !*** valid icd200

      dt=af0+af1*(t-t0c)+af2*(t-t0c)*(t-t0c)       !*** valid icd200
      bcclok1=dt

*** 2006may10 -- dgm notes
*** IGS does NOT apply sat P1P2 DCB corrections to clocks "by agreed convention"
*** thus, sat P1P2 DCB must be applied to IGS clocks if single freq. 
*** this is same convention as icd-200 20.3.3.3.3.2

      if(.not.lq2frq()) bcclok1=bcclok1-tgd

      return
      end
      double precision function bcclok2(tin,dt)
      
*** compute satellite clock correction (relativity term)
*** sense of the corrector is:   t=tsv-dt-dtr

*** icd200block icd-gps-200c + irn-200c-002 97sep25
***   parameter(gm   = 3.986005d14)                     !*** 20.3.3.3.3.1
***   parameter(we   = 7.2921151467d-5) !*** rad/sec    !*** table 20-IV
***   parameter(gpspi= 3.1415926535898d0)               !*** 20.3.3.4.3.2
***   parameter(sol  = 299792458.d0)                    !*** 20.3.4.3
***   parameter(bigf =-4.442807633d-10) !*** sec/m**0.5 !*** 20.3.3.3.3.1

      implicit double precision(a-h,o-z)
      parameter(bigf=-4.442807633d-10)
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

      t=tin
      if((t-t0c).gt. 302400.d0 ) t=t-604800.d0     !*** handle week rollover
      if((t-t0c).lt.-302400.d0 ) t=t+604800.d0     !*** valid icd200

*** relativity term

      ek=eccano(t-dt)
      dtr=bigf*e*sqrta*dsin(ek)              !*** icd200 -- 20.3.3.3.3.1

      bcclok2=dtr

      return
      end
      double precision function bctgd()
      
*** return the group delay (clock correction when single frequency)
*** sense of the corrector is:   tsv=tsv-tgd
*** see 20.3.3.3.3.2 in icd-gps-200

      implicit double precision(a-h,o-z)
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

      bctgd=tgd             !*** simply return the group delay

      return
      end
************************************************************************
      subroutine boterp2(tin,xk,yk,zk)

*** compute ECBF XYZ at time t from broadcast elements
***               units: seconds, meters, radians
*** note: input t corrected for SV clock error (and relativity)

*** icd200block icd-gps-200c + irn-200c-002 97sep25
***   parameter(gm   = 3.986005d14)                     !*** 20.3.3.3.3.1
***   parameter(we   = 7.2921151467d-5) !*** rad/sec    !*** table 20-IV
***   parameter(gpspi= 3.1415926535898d0)               !*** 20.3.3.4.3.2
***   parameter(sol  = 299792458.d0)                    !*** 20.3.4.3
***   parameter(bigf =-4.442807633d-10) !*** sec/m**0.5 !*** 20.3.3.3.3.1

      implicit double precision(a-h,o-z)
      parameter(gm=3.986005d14)
      parameter(we=7.2921151467d-5)                     !*** rad/sec
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

      t=tin
      if((t-t0c).gt. 302400.d0 ) t=t-604800.d0     !*** handle week rollover
      if((t-t0c).lt.-302400.d0 ) t=t+604800.d0     !*** valid icd200

*** mean motion

      a   = sqrta*sqrta
      en0 = dsqrt(gm/(a*a*a))

*** time since orbit reference epoch

      tk = t-t0e
      write(*,*) 'tk=',tk

*** corrected mean motion

      en = en0+deln

*** mean anomaly, M

      emk = em0+en*tk

*** solve kepler's equation for eccentric anomaly, E

      ek    = dkepeq(emk)
      sinek = dsin(ek)
      cosek = dcos(ek)

*** true anomaly, f

      f = datan2(dsqrt(1.d0-e*e)*sinek, cosek-e)

*** argument of latitude, u

      u   = f+w
      cu2 = dcos(u+u)
      su2 = dsin(u+u)

*** corrections to the arg. of lat., radius, and inclination

      duk = cuc*cu2+cus*su2
      drk = crc*cu2+crs*su2
      dik = cic*cu2+cis*su2

*** correct the arg. of lat., radius, and inclination

      uk    = u                + duk
      rk    = a*(1.d0-e*cosek) + drk
      eyek  = eye0+eyedot*tk   + dik
      ceyek = dcos(eyek)

*** position in the orbital plane

      xpk = rk*dcos(uk)
      ypk = rk*dsin(uk)

*** correct the longitude of the ascending node

      omgk  = omg0+(omgdot-we)*tk-we*t0e
      comgk = dcos(omgk)
      somgk = dsin(omgk)

*** compute ecbf coordinates

      xk = xpk*comgk-ypk*somgk*ceyek
      yk = xpk*somgk+ypk*comgk*ceyek
      zk =           ypk      *dsin(eyek)

      return
      end
      double precision function eccano(t)

*** compute eccentric anomaly at time T from broadcast elements

*** icd200block icd-gps-200c + irn-200c-002 97sep25
***   parameter(gm   = 3.986005d14)                     !*** 20.3.3.3.3.1
***   parameter(we   = 7.2921151467d-5) !*** rad/sec    !*** table 20-IV
***   parameter(gpspi= 3.1415926535898d0)               !*** 20.3.3.4.3.2
***   parameter(sol  = 299792458.d0)                    !*** 20.3.4.3
***   parameter(bigf =-4.442807633d-10) !*** sec/m**0.5 !*** 20.3.3.3.3.1

      implicit double precision(a-h,o-z)
      parameter(gm=3.986005d14)
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

      if((t-t0c).gt. 302400.d0 ) t=t-604800.d0     !*** handle week rollover
      if((t-t0c).lt.-302400.d0 ) t=t+604800.d0     !*** valid icd200

      a=sqrta*sqrta                !*** semimajor axis
      en0=dsqrt(gm/(a*a*a))        !*** mean motion
      tk=t-t0e                     !*** time since orbit reference epoch
      en=en0+deln                  !*** corrected mean motion
      emk=em0+en*tk                !*** mean anomaly, M
      eccano=dkepeq(emk)           !*** solve kepler's eq for ecc anomaly, E

      return
      end
      double precision function dkepeq(em)
      
*** solve for eccentric anomaly given mean anomaly and orbital eccentricity
*** use simple fixed point iteration of kepler's equation

      implicit double precision(a-h,o-z)
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

*** initialize eccentric anomaly

      ecca0=em+e*dsin(em)

*** first iteration

      ecca =ecca0+e*dsin(ecca0)

*** exit only on convergence

    1 if(dabs((ecca-ecca0)/ecca).gt.1.d-14) then
        ecca0=ecca
        ecca=em+e*dsin(ecca0)
        go to 1
      endif
      dkepeq=ecca

      return
      end
************************************************************************
*** expected test results:

***   call bcinit
***   call boterp2( 3104.d0,x,y,z)
***   call boterp2( 3204.d0,x,y,z)
***   call boterp2( 4104.d0,x,y,z)
***   call boterp2(13104.d0,x,y,z)

***  x=-17212647.7969  y=-20205593.2676  z=  1151304.1641
***  x=-17199667.6706  y=-20234605.2305  z=   834485.2910
***  x=-16972873.7180  y=-20363862.4894  z= -2016782.8591
***  x= -2061865.9599  y=-15633481.5430  z=-21527450.2128

*** results from 2004aug30  (note: no sat clock corrn's on input times)
***  xyz= -17212647.7969   -20205593.2678     1151304.1627
***  xyz= -17199667.6705   -20234605.2306      834485.2895
***  xyz= -16972873.7178   -20363862.4894    -2016782.8606
***  xyz=  -2061865.9586   -15633481.5428   -21527450.2131
************************************************************************
      subroutine bcinit

*** initialize to test values

      implicit double precision(a-h,o-z)
      save  /bcstuf/
      common/bcstuf/iprn,iepch,
     *  djts ,t0c   ,af0   ,af1   ,af2   ,t0e  ,sqrta ,e   ,eye0  ,omg0,
     *  w    ,em0   ,deln  ,eyedot,omgdot,cuc  ,cus   ,crc ,crs   ,cic,
     *  cis  ,diode ,dl2cd ,wkno  ,dl2pd ,svac ,svhl  ,tgd ,diodc ,tot

      t0c   =  3.10400000000000d+03
      af2   =  0.00000000000000d+00
      af1   =  2.04636307898909d-12
      af0   =  4.73577529191971d-07

      crs   = -1.74687500000000d+01
      deln  =  4.57340478638085d-09
      em0   =  1.63307323511810d+00

      cuc   = -9.68575477600099d-07
      e     =  4.74695244338363d-03
      cus   =  2.30222940444947d-06
      sqrta =  5.15357911109924d+03

      t0e   =  3.10400000000000d+03
      cic   =  7.26431608200074d-08
      omg0  =  1.12194333211744d+00
      cis   = -4.28408384323121d-08

      eye0  =  9.59844678252147d-01
      crc   =  3.32750000000000d+02
      w     =  1.44611981813501d+00
      omgdot= -8.27498754358907d-09

      eyedot= -7.96461747257267d-11

      return
      end
************************************************************************
*** orbit load and interpolation ***************************************
*** 2004 july 11 version ***********************************************
************************************************************************
      subroutine lodorb(orbits)

*** load ephemeris in sp3 ascii format

      implicit double precision(a-h,o-z)
      character*60 card
      character*14 osource
      parameter(mxprn=32,mxepch=192)
      dimension orbits(mxepch + 4*mxprn*mxepch)
      parameter(tiny=1.d-6)
      save  /satstf/
      common/satstf/tstr,tstp,dlt,t0mx,imx,npt,n2,nst,nep,it,ix,iy,iz,id
      save  /satstf2/
      common/satstf2/idx0s(mxepch,mxprn),ibds(mxepch,mxprn)
      common/lus/lst,lin,leph,lres

*** number of epochs and number of sats (for loop control -- nloop)

      nsat=mxprn

      read(leph,1) iyr,imo,idy,ihr,imn,sec,nepoch,osource
    1 format(3x,i4,4i3,f12.8,i8,7x,a14)
      if(nepoch.lt.9.or.nepoch.gt.mxepch) then
        write(*,*) 'ephem nepoch error, nepoch= ',nepoch
        stop 47394
      endif
      write(lst,'(a,a)') 'orbit ref sys/source -- ',osource
      read(leph,'(a60)')   card
      read(leph,'(4x,i2)') nloop

*** initialize start indexes and bad data flags

      n8=nepoch-8
      do iprn=1,mxprn
        do jep=1,n8
          idx0s(jep,iprn)=jep
        enddo
        do jep=n8+1,mxepch
          idx0s(jep,iprn)=n8
        enddo
        do jep=1,mxepch
          ibds(jep,iprn)=0
        enddo
      enddo

*** skip over rest of the sp3 format header

      do i=4,18
        read(leph,'(a60)') card
      enddo
      read(leph,'(a60)') card                 !*** echo orbit type
      write(lst,'(a60)') card
      do i=20,22
        read(leph,'(a60)') card
      enddo

*** compute indicies for the orbit data block and load common

      it    =1
      ix    =it+     nepoch
      iy    =ix+nsat*nepoch
      iz    =iy+nsat*nepoch
      id    =iz+nsat*nepoch
      itotal=id+nsat*nepoch-1
      nst=nsat
      nep=nepoch

*** initialize the orbit data block to 0

      do 3 i=1,itotal
    3 orbits(i)=0.d0

*** master loop over ephemeris file
*** read the epoch headers, then find position (P) records
*** exit the loop after loading 'nepoch' epochs   (counted by nt)

      nt=0
      tstr=+1.d38
      tstp=-1.d38
  100 read(leph,'(a60)',end=777) card
      if(card(1:1).eq.'*') then
        read(card,'(3x,i4,4i3,f12.8)') iyr,imo,idy,ihr,imn,sec
        call civjts(iyr,imo,idy,ihr,imn,sec,tsec)

*** module assumes orbits in monotonically ascending time order

        nt=nt+1
        orbits(nt)=tsec
        if(tsec.lt.tstr) tstr=tsec
        if(tsec.gt.tstp) tstp=tsec

*** immediately make ephemeris data into meters and seconds
*** bypass null markers (dt = 999999.999999)

        do 10 i=1,nloop
  101     read(leph,'(a60)') card
          if(card(1:1).eq.'*') stop 89756
          if(card(1:1).ne.'P'.and.card(1:1).ne.'p') go to 101
          read(card,'(1x,i3,4f14.6)') is,x,y,z,dt
          if(is.lt.1.or.is.gt.mxprn) then
            write(*,*) 'ephem prn error, prn= ',is
            stop 47395
          endif
          if(dt.le.999990.d0) then
            x=x*1000.d0
            y=y*1000.d0
            z=z*1000.d0
            dt=dt/1.d6
            call lodor2(nt,is,x,y,z,dt,
     *                  orbits(ix),orbits(iy),orbits(iz),orbits(id))

*** set bad data flags

          else
            ibds(nt,is)=1
          endif
   10   continue
        if(nt.eq.nepoch) go to 777
      endif
      go to 100
 
*** end of file encountered
 
  777 continue

*** set remaining constants for index work

      dlt=dble( idnint((tstp-tstr)/(nep-1)) )
      npt=9
      n2=(npt-1)/2
      imx=nep-npt+1
      t0mx=(imx-1)*dlt+tstr

      write(lst,'(a,2f10.2,f7.2,i6)') 'orbit strt/stop,delt,neph ',
     *                                 tstr,tstp,dlt,nep

**********************************************************************
*** test code -- erosion (if marginal orbit error)
***   do iprn=1,mxprn
***     do jep=1,nepoch
***       if(ibds(jep,iprn).eq.1) then
***         if(jep-1.ge.     1) then
***           if(ibds(jep-1,iprn).eq.0) ibds(jep-1,iprn)=2
***         endif
***         if(jep+1.le.nepoch) then
***           if(ibds(jep+1,iprn).eq.0) ibds(jep+1,iprn)=2
***         endif
***       endif
***     enddo
***   enddo
**********************************************************************

      n8=nepoch-8
      do iprn=1,mxprn

*** advance indicies -- sweep front to rear

        do j=1,nepoch
          if(ibds(j,iprn).gt.0) then
            idx0s(j-4,iprn)=0                         !*** null pointer
            if(j.lt.n8) then
              if(idx0s(j-3,iprn).ne.0) idx0s(j-3,iprn)=j+1
              if(idx0s(j-2,iprn).ne.0) idx0s(j-2,iprn)=j+1
              if(idx0s(j-1,iprn).ne.0) idx0s(j-1,iprn)=j+1
              if(idx0s(j  ,iprn).ne.0) idx0s(j  ,iprn)=j+1
            else
              do k=n8-3,nepoch                  !*** no room for advance
                idx0s(k,iprn)=0
              enddo
            endif
          endif
        enddo

*** retard indicies -- sweep rear to front

        do j=nepoch,1,-1
          if(ibds(j,iprn).gt.0) then
            if((j-8).ge.1) then
              if(idx0s(j-8,iprn).ne.0) idx0s(j-8,iprn)=j-9
              if(idx0s(j-7,iprn).ne.0) idx0s(j-7,iprn)=j-9
              if(idx0s(j-6,iprn).ne.0) idx0s(j-6,iprn)=j-9
              if(idx0s(j-5,iprn).ne.0) idx0s(j-5,iprn)=j-9
            else
              if((j-7).ge.1) idx0s(j-7,iprn)=0
              if((j-6).ge.1) idx0s(j-6,iprn)=0
              if((j-5).ge.1) idx0s(j-5,iprn)=0
            endif
          endif
        enddo

*** outer-most loop over prn's
      enddo

*** initialize interpolation coefficients  (hard coded for 9)

      call itrini

      return
      end
      subroutine lodor2(nt,is,x,y,z,dt,xs,ys,zs,ds)

*** place data into storage locations in orbit data block

      implicit double precision(a-h,o-z)
      dimension xs(nep,nst),ys(nep,nst),zs(nep,nst),ds(nep,nst)
      save  /satstf/
      common/satstf/tstr,tstp,dlt,t0mx,imx,npt,n2,nst,nep,it,ix,iy,iz,id

      xs(nt,is)=x
      ys(nt,is)=y
      zs(nt,is)=z
      ds(nt,is)=dt

      return
      end
      logical function oterp(iprn,tsec,orbits,x,y,z,dt,ierr)

*** interpolation of orbit
*** iprn is prn identifier for a satellite
*** input time, tsec, is gps time (maintained by usaf) w.r.t. mjd0
*** output (xyz) units of m in orbit reference system
*** output (dt)  units of sec
*** data in /satstf/ loaded by lodsat()

*** ierr=1  not currently used
*** ierr=2  prn not in orbit file
*** ierr=3  time boundary violation (extrapolation prohibited)

      implicit double precision(a-h,o-z)
      logical oterp2
      dimension orbits(*)
      save /satstf/
      common/satstf/tstr,tstp,dlt,t0mx,imx,npt,n2,nst,nep,it,ix,iy,iz,id

*** use indicies to extract sub-arrays of orbits()

      if(.not.oterp2(iprn,tsec,
     *           orbits(it),orbits(ix),orbits(iy),orbits(iz),orbits(id),
     *           x,y,z,dt,ierr)) then
        oterp=.false.
      else
        oterp=.true.
      endif

      return
      end
      logical function oterp2(is,tsec,ts,xs,ys,zs,ds,x,y,z,dt,ierr)

*** orbit interpolation subroutine  (called by oterp)

      implicit double precision(a-h,o-z)
      parameter(tiny=1.d-2)
      dimension ts(nep),xs(nep,nst),ys(nep,nst),zs(nep,nst),ds(nep,nst)
      save /satstf/
      common/satstf/tstr,tstp,dlt,t0mx,imx,npt,n2,nst,nep,it,ix,iy,iz,id
      parameter(mxprn=32,mxepch=192)
      save  /satstf2/
      common/satstf2/idx0s(mxepch,mxprn),ibds(mxepch,mxprn)
      common/lus/lst,lin,leph,lres

*** is  -- prn for a satellite (1 <= is <= nst)
*** nst -- number of satellite prns that were loaded
*** nep -- number of orbit epochs that were loaded

*** this line is bogus -- keep compiler quiet ******************

      ts(1)=ts(1)

*** prevent extrapolation

      if(tsec.lt.tstr.or.tsec.gt.tstp) then
        ierr=3
        oterp2=.false.
        return
      endif

*** routine for finding index into table
*** produces normalized time [0,1,...,8] --> should be 3.5 < tnorm < 4.5

      i=(idnint((tsec-tstr)/dlt)+1)-n2
      t0=(i-1)*dlt+tstr

*** impose orbit boundary limits

      if(i.lt.1) then
        i=1
        t0=tstr
      elseif(i.gt.imx) then
        i=imx
        t0=t0mx
      endif

*** use substitute index to handle orbit dropouts

      i=idx0s(i,is)
      if(i.le.0) then
        ierr=2
        oterp2=.false.
        return
      endif

*** scan for imbedded orbit error tags (9-point interpolation)

      do j=i,i+8
        r=xs(j,is)*xs(j,is)+ys(j,is)*ys(j,is)+zs(j,is)*zs(j,is)
        if(r.le.tiny) then
          ierr=2
          oterp2=.false.
          return
        endif
      enddo

*** recompute reference time based on substitute index

      t0=(i-1)*dlt+tstr
      t=(tsec-t0)/dlt

      call iterp9(t,xs(i,is),x)
      call iterp9(t,ys(i,is),y)
      call iterp9(t,zs(i,is),z)
      call iterp9(t,ds(i,is),dt)
      ierr=0
      oterp2=.true.

      return
      end
***********************************************************************
      subroutine iterp9(t,xs,x)

*** 9-th order interpolator                  -- equally-spaced points
*** time normalized 0,1,...,8                -- should be 3.5 < t < 4.5
*** coefficents, c(), initialized by itrini  -- see Ben Remondi dissertation

*** patched 19-jan-96 for t exactly equal to 4.0 (rev. 2004jul07)
*** patch revised  -- tol for normalized t for 1mm over 900 sec (rev. 2004jul07)

      implicit double precision(a-h,o-z)
*** patch -- tol for normalized t for 1mm over 900 sec
***** parameter(eps=1.d-13)
      parameter(eps=2.d-10)
      dimension xs(9)
      save  /coeff9/
      common/coeff9/c(9)

*** return stored value if t is exact integer time (avoid division by 0)

      intt=idnint(t)
      tint=dble(intt)
      if(dabs(t-tint).le.eps) then
        if(intt.ge.0.and.intt.le.8) then
          x=xs(intt+1)
          return
        else
          stop 88998
        endif
      endif

*** normal interpolation

      powr=1.d0
      x=0.d0

      do 100 i=1,9
        dt=(t-dble(i-1))
        powr=dt*powr
        x=x+xs(i)/(c(i)*dt)
  100 continue
      x=x*powr/24.d0

      return
      end
***********************************************************************
*     subroutine iterp9(t,xs,x)

*** 9-th order interpolator                  -- equally-spaced points
*** time normalized 0,1,...,8                -- should be 3.5 < t < 4.5
*** coefficents, c(), initialized by itrini  -- see Ben Remondi dissertation

*     implicit double precision(a-h,o-z)
*     dimension xs(9)
*     save /coeff9/
*     common/coeff9/c(9)

*     powr=1.d0
*     x=0.d0

*     do 100 i=1,9
*       dt=(t-dble(i-1))
*       powr=dt*powr
*       x=x+xs(i)/(c(i)*dt)
* 100 continue
*     x=x*powr/24.d0

*     return
*     end
***********************************************************************
      subroutine itrini

*** initialize coefficients for 9-th order "lagrangean" interpolator
*** follows theory of Ben Remondi  (c.f. his dissertation)

      implicit double precision(a-h,o-z)
      save  /coeff9/
      common/coeff9/c(9)

      c(1)=40320.d0 /24.d0
      c(2)=-5040.d0 /24.d0
      c(3)= 1440.d0 /24.d0
      c(4)= -720.d0 /24.d0
      c(5)=  576.d0 /24.d0
      c(6)= -720.d0 /24.d0
      c(7)= 1440.d0 /24.d0
      c(8)=-5040.d0 /24.d0
      c(9)=40320.d0 /24.d0

      return
      end
************************************************************************
*** time conversion ****************************************************
************************************************************************
      subroutine setjd0(iyr,imo,idy)

*** set the integer part of a modified julian date as epoch, mjd0
*** the modified julian day is derived from civil time as in civmjd()
*** allows single number expression of time in seconds w.r.t. mjd0

      implicit double precision(a-h,o-z)
      integer y
      save /mjdoff/
      common/mjdoff/mjd0

      if(iyr.lt.1900) stop 34587

      if(imo.le.2) then
        y=iyr-1
        m=imo+12
      else
        y=iyr
        m=imo
      endif

      it1=365.25d0*y
      it2=30.6001d0*(m+1)
      mjd=it1+it2+idy-679019

*** now set the epoch for future time computations

      mjd0=mjd

      return
      end
      subroutine civjts(iyr,imo,idy,ihr,imn,sec,tsec)

*** convert civil date to time in seconds past mjd epoch, mjd0
*** requires initialization of mjd0 by setjd0()

*** imo in range 1-12, idy in range 1-31
*** only valid in range mar-1900 thru feb-2100     (leap year protocols)
*** ref: hofmann-wellenhof, 2nd ed., pg 34-35
*** adapted from civmjd()

      implicit double precision(a-h,o-z)
      integer y
      save /mjdoff/
      common/mjdoff/mjd0

      if(iyr.lt.1900) stop 34589

      if(imo.le.2) then
        y=iyr-1
        m=imo+12
      else
        y=iyr
        m=imo
      endif

      it1=365.25d0*y
      it2=30.6001d0*(m+1)
      mjd=it1+it2+idy-679019

      tsec=(mjd-mjd0)*86400.d0+3600*ihr+60*imn+sec

      return
      end
      subroutine jtsciv(tsec,iyr,imo,idy,ihr,imn,sec)

*** convert time in seconds past mjd0 epoch into civil date
*** requires initialization of mjd0 by setjd0()

*** imo in range 1-12, idy in range 1-31
*** only valid in range mar-1900 thru feb-2100
*** ref: hofmann-wellenhof, 2nd ed., pg 34-35
*** adapted from mjdciv()

      implicit double precision(a-h,o-z)
      save /mjdoff/
      common/mjdoff/mjd0

      mjd=mjd0+tsec/86400.d0
*** the following equation preserves significant digits
      fmjd=dmod(tsec,86400.d0)/86400.d0

      rjd=mjd+fmjd+2400000.5d0
      ia=(rjd+0.5d0)
      ib=ia+1537
      ic=(ib-122.1d0)/365.25d0
      id=365.25d0*ic
      ie=(ib-id)/30.6001d0

*** the fractional part of a julian day is (fractional mjd + 0.5)
*** therefore, fractional part of julian day + 0.5 is (fractional mjd)

      it1=ie*30.6001d0
      idy=ib-id-it1+fmjd
      it2=ie/14.d0
      imo=ie-1-12*it2
      it3=(7+imo)/10.d0
      iyr=ic-4715-it3

      tmp=fmjd*24.d0
      ihr=tmp
      tmp=(tmp-ihr)*60.d0
      imn=tmp
      sec=(tmp-imn)*60.d0

      return
      end
********************************************************************
      double precision function djtssow(tsec)

*** convert julian seconds to gps seconds of week
*** requires initialization of mjd0 by setjd0()

      implicit double precision(a-h,o-z)
      parameter(mjd6jan80 = 44244)              !*** mjd for begin GPS
      save  /mjdoff/
      common/mjdoff/mjd0

*** steady increment -- decrement on week rollover
*** (validated: cross check against broadcast t0e)

      nwks =         (mjd0-mjd6jan80)/7
      sow  = tsec + ((mjd0-mjd6jan80-(nwks*7))*86400.d0)
      if(sow.ge.604800.d0) sow=sow-604800.d0
      djtssow = sow

      return
      end
********************************************************************
      subroutine civmjd(iyr,imo,idy,ihr,imn,sec,mjd,fmjd)

*** convert civil date to modified julian date

*** imo in range 1-12, idy in range 1-31
*** only valid in range mar-1900 thru feb-210      (leap year protocols)
*** ref: hofmann-wellenhof, 2nd ed., pg 34-35
*** operation confirmed against table 3.3 values on pg.34

      implicit double precision(a-h,o-z)
      integer y

      if(iyr.lt.1900) stop 34588

      if(imo.le.2) then
        y=iyr-1
        m=imo+12
      else
        y=iyr
        m=imo
      endif

      it1=365.25d0*y
      it2=30.6001d0*(m+1)
      mjd=it1+it2+idy-679019

      fmjd=(3600*ihr+60*imn+sec)/86400.d0

      return
      end
      subroutine mjdciv(mjd,fmjd,iyr,imo,idy,ihr,imn,sec)

*** convert modified julian date to civil date

*** imo in range 1-12, idy in range 1-31
*** only valid in range mar-1900 thru feb-2100
*** ref: hofmann-wellenhof, 2nd ed., pg 34-35
*** operation confirmed for leap years (incl. year 2000)

      implicit double precision(a-h,o-z)

      rjd=mjd+fmjd+2400000.5d0
      ia=(rjd+0.5d0)
      ib=ia+1537
      ic=(ib-122.1d0)/365.25d0
      id=365.25d0*ic
      ie=(ib-id)/30.6001d0

*** the fractional part of a julian day is fractional mjd + 0.5
*** therefore, fractional part of julian day + 0.5 is fractional mjd

      it1=ie*30.6001d0
      idy=ib-id-it1+fmjd
      it2=ie/14.d0
      imo=ie-1-12*it2
      it3=(7+imo)/10.d0
      iyr=ic-4715-it3

      tmp=fmjd*24.d0
      ihr=tmp
      tmp=(tmp-ihr)*60.d0
      imn=tmp
      sec=(tmp-imn)*60.d0

      return
      end
************************************************************************
*** matrix mashers *****************************************************
************************************************************************
      subroutine writev(a,m)

*** routine to write a vector 

      implicit double precision(a-h,o-z)
      dimension a(m)
      common/lus/lst,lin,leph,lres

      do 10 i=1,m 
   10 write(lst,1) a(i) 
    1 format(' ',1pd30.20)
      return
      end 
      subroutine writem(a,m,n)
 
*** routine to write a matrix 

      implicit double precision(a-h,o-z)
      dimension a(m,n)
      common/lus/lst,lin,leph,lres

      do 10 i=1,m 
   10 write(lst,1) (a(i,j),j=1,n) 
    1 format(' ',1p4d18.10) 
      return
      end
      double precision function viewm(a,i,j,nr)

*** view an element of a 2-d array

      implicit double precision(a-h,o-z)
      dimension a(nr,*)

      viewm=a(i,j)

      return
      end
      subroutine putm2d(val,a,i,j,nr)

*** put an element into a 2-d array

      implicit double precision(a-h,o-z)
      dimension a(nr,*)

      a(i,j)=val

      return
      end
      subroutine vecprd(x,u,n,val)

*** compute inner product of two vectors, val = x'u

      implicit double precision(a-h,o-z)
      dimension x(n),u(n)

      val=0.d0
      do 1 i=1,n
    1 val=val+x(i)*u(i)

      return
      end 
      subroutine innerp(x,n,val)

*** compute inner product of vector

      implicit double precision(a-h,o-z)
      dimension x(n)

      val=0.d0
      do 1 i=1,n
    1 val=val+x(i)*x(i)

      return
      end
      subroutine ab(a,b,r,l,m,n)
 
*** form the matrix product r=ab 
*** the matrices a and b are returned unchanged

      implicit double precision(a-h,o-z)
      dimension a(l,m),b(m,n),r(l,n)

      do 5 i=1,l
      do 5 j=1,n
      r(i,j)=0.d0
      do 5 k=1,m
    5 r(i,j)=r(i,j)+a(i,k)*b(k,j) 
      return
      end 
      subroutine invert(a,n)

*** routine to invert a matrix in place 

      implicit double precision(a-h,o-z)
      dimension a(n,n)

      do 2 i=1,n
      aii=1.d0/a(i,i)
      a(i,i)=aii
      do 2 j=1,n
      if(i.eq.j) go to 2
      aji=a(j,i)*aii
      a(j,i)=aji
      do 1 k=1,n
      if(i.eq.k) go to 1
      a(j,k)=a(j,k)-aji*a(i,k)
      if(j.ne.n) go to 1
      a(i,k)=-aii*a(i,k)
    1 continue
    2 continue
      ann=-a(n,n) 
      k=n-1 
      do 3 j=1,k
    3 a(n,j)=ann*a(n,j) 
      return
      end 
      subroutine nrmal2(an,u,d,f,p,bw,lc,nd,n) 

***  form normals for observation equations one observation at a time 
***            *****(nx + u = 0)***** 
***        n=a'pa         (n matrix stored in an) 
***        u=a'pl         (l stored in f) 
***  calling sequence 
***    1)  call nitial  (one time to clear normals) 
***    2)  call normal  (once for each observation) 
***    3)  call fill    (one time to fill in lower triangular)
*** 
***  d = non-zero elements of a row of the a matrix 
***  lc= column numbers of non-zero elements in d.  elements
***      of lc must be in ascending order and correspond to 
***      d, i.e., d(j) is the non-zero element in column lc(j)
***  nd= number of elements in d and lc 
***  n = order of the system (number of unknowns) 
***  bw= l'pl accumulated (basement window)

      implicit double precision(a-h,o-z) 
      dimension an(n,n),u(n),d(nd),lc(nd) 

      pf=p*f
      bw=bw+f*pf
      do 5 i=1,nd 
      li=lc(i)
      u(li)=u(li)+d(i)*pf 
      do 5 j=i,nd 
      lj=lc(j)
    5 an(li,lj)=an(li,lj) + d(i)*d(j)*p 
      return

*** clear normals

      entry nitil2(an,u,bw,n)
      do 10 i=1,n 
      u(i)=0.d0
      do 10 j=i,n 
   10 an(i,j)=0.d0 
      bw=0.d0 
      return

*** fill in the lower triangular portion of an 

      entry fill(an,n)
      do 15 i=1,n 
      do 15 j=i,n 
   15 an(j,i)=an(i,j) 
      return
      end
***********************************************************************
***** mode managers ***************************************************
***********************************************************************
      subroutine modequery

*** query on modes and set flags

      implicit double precision(a-h,o-z)
      character*1 yesno
      logical        l2freq,ldtr4p,lprecr,lhalf
      save  /mymodes/
      common/mymodes/l2freq,ldtr4p,lprecr,lhalf

*** l2freq -- application of Tgd
***        -- .true.  if 2 freq with *NO* sat DCB corrections
***        -- .false. if 1 freq
***        -- .false. if 2 freq and with valid sat DCB corrections
*** ldtr4p -- in geomet() select flavor of comrng() (dtr from p/r vs. compute.)
*** lprecr -- in getepch() apply fractional time correction to data
*** lhalf  -- flag half-wavelengh ambiguities

      l2freq =.false.
      ldtr4p =.false.
      lprecr =.false.
      lhalf  =.false.

***** write(*,'(a$)') '2 frequency?   : '
***** read(*, '(a)' ) yesno
***** if(yesno(1:1).eq.'y'.or.yesno(1:1).eq.'Y') l2freq =.true.

***** write(*,'(a$)') 'Rcr clock-4parm?:'
***** read(*, '(a)' ) yesno
***** if(yesno(1:1).eq.'y'.or.yesno(1:1).eq.'Y') ldtr4p =.true.

***** write(*,'(a$)') 'Pre-correct?   : '
***** read(*, '(a)' ) yesno
***** if(yesno(1:1).eq.'y'.or.yesno(1:1).eq.'Y') lprecr =.true.

*** switch off and use these prompts

      l2freq =.false.
      ldtr4p =.false.
      lprecr =.false.

      write(*,'(a$)') 'Half wavelength?: '
      read(*, '(a)' ) yesno
      if(yesno(1:1).eq.'y'.or.yesno(1:1).eq.'Y') lhalf =.true.

      return
      end
      logical function lq2frq()

*** return l2freq flag

      implicit double precision(a-h,o-z)
      logical        l2freq,ldtr4p,lprecr,lhalf
      save  /mymodes/
      common/mymodes/l2freq,ldtr4p,lprecr,lhalf

      lq2frq=l2freq

      return
      end
      logical function lqdtr4()

*** return ldtr4p flag

      implicit double precision(a-h,o-z)
      logical        l2freq,ldtr4p,lprecr,lhalf
      save  /mymodes/
      common/mymodes/l2freq,ldtr4p,lprecr,lhalf

      lqdtr4=ldtr4p

      return
      end
      logical function lqprec()

*** return lprecr flag

      implicit double precision(a-h,o-z)
      logical        l2freq,ldtr4p,lprecr,lhalf
      save  /mymodes/
      common/mymodes/l2freq,ldtr4p,lprecr,lhalf

      lqprec=lprecr

      return
      end
      logical function lqhalf()

*** return lhalf flag

      implicit double precision(a-h,o-z)
      logical        l2freq,ldtr4p,lprecr,lhalf
      save  /mymodes/
      common/mymodes/l2freq,ldtr4p,lprecr,lhalf

      lqhalf=lhalf

      return
      end
      subroutine dumpmodes

*** query on modes and set flags

      implicit double precision(a-h,o-z)
      character*1 yesno
      logical        l2freq,ldtr4p,lprecr,lhalf
      save  /mymodes/
      common/mymodes/l2freq,ldtr4p,lprecr,lhalf
      common/lus/lst,lin,leph,lres

      write(lst,'(a$)') 'modes:  '

      if(l2freq)then
        write(lst,'(a$)') '2-freq '
      else
        write(lst,'(a$)') '1-freq '
      endif

      if(ldtr4p)then
        write(lst,'(a$)') 'ls-dtr '
      else
        write(lst,'(a$)') 'pr-dtr '
      endif

      if(lprecr)then
        write(lst,'(a$)') 'pre-cor '
      else
        write(lst,'(a$)') 'no-precor '
      endif

      if(lhalf)then
        write(lst,'(a$)') 'half-wave '
      else
        write(lst,'(a$)') 'full-wave '
      endif

*** end the line

      write(lst,'(a)') ''

      return
      end
